import"./each.BqUK7mNK.js";import{p as xn,f as En,b as Sn,t as In,c as Rn,a as An,s as zn,j as qn,e as Mn,r as Nn}from"./render.CzOj0u-p.js";import{ae as _r,ag as Wt,g as Pn,e as Dn,O as _n,k as Cn}from"./definitions.Dd0A7QR4.js";import{c as Un}from"./en.BRoYHVPv.js";import{B as Fn}from"./basic-form.VvFHnfe5.js";import{h as Tn}from"./checkboxes-include.BSSJX23c.js";import{t as Ln,a as Vn}from"./errors.BQ2nDSVs.js";import{d as Wn}from"./defaults.CGWrLkd2.js";import{i as Jn,u as Kn,s as Hn}from"./index.BPQVTpeN.js";import"./_commonjsHelpers.DaWZu8wl.js";import"./snippet.Wjih3T4S.js";import"./file.Br2FeIev.js";import"./form.B6pmN7Bx.js";import"./content.BSjKH8fr.js";import"./submit-button.4cIXeLb7.js";import"./assert.CZwgD7MO.js";import"./file-include.DMLglpQu.js";const Zn={"data-url":/^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/},Gn={includeErrors:!0,allErrors:!0,$schemaDefault:"http://json-schema.org/draft-07/schema",extraFormats:!0,formats:Zn};var Mt,Er;function wt(){if(Er)return Mt;Er=1;class s extends String{}const q=new Set(["<",">","<=",">="]),E=e=>`\\u${e.toString(16).padStart(4,"0")}`,a=e=>{if([1/0,-1/0,NaN,void 0,null].includes(e))return`${e}`;if(!["string","boolean","number"].includes(typeof e)){if(typeof e!="object")throw new Error("Unexpected value type");const i=Object.getPrototypeOf(e);if(!(i===Array.prototype&&Array.isArray(e)||i===Object.prototype))throw new Error("Unexpected object given as value")}return JSON.stringify(e).replace(/([{,])"__proto__":/g,'$1["__proto__"]:').replace(/[^\\]"__proto__":/g,()=>{throw new Error("Unreachable")}).replace(/[\u2028\u2029]/g,i=>E(i.charCodeAt(0)))},y=(e,...f)=>{const i=e.replace(/%[%drscjw]/g,c=>{if(c==="%%")return"%";if(f.length===0)throw new Error("Unexpected arguments count");const l=f.shift();switch(c){case"%d":if(typeof l=="number")return l;throw new Error("Expected a number");case"%r":if(l instanceof RegExp)return y("new RegExp(%j, %j)",l.source,l.flags);throw new Error("Expected a RegExp instance");case"%s":if(l instanceof s)return l;throw new Error("Expected a safe string");case"%c":if(q.has(l))return l;throw new Error("Expected a compare op");case"%j":return a(l);case"%w":if(Number.isInteger(l)&&l>=0)return" ".repeat(l);throw new Error("Expected a non-negative integer for indentation")}throw new Error("Unreachable")});if(f.length!==0)throw new Error("Unexpected arguments count");return new s(i)},h=e=>{if(!/^[a-z][a-z0-9_]*$/i.test(e))throw new Error("Does not look like a safe id");return new s(e)},w=e=>(...f)=>{if(!f.every(i=>i instanceof s))throw new Error("Unsafe arguments");return new s(e(...f))},N=e=>/^[a-z][a-z0-9_().]*$/i.test(e)||/^\([^()]+\)$/i.test(e)?e:y("(%s)",e),Q=w((...e)=>e.some(f=>`${f}`=="true")?"true":e.join(" || ")||"false"),ne=w((...e)=>e.some(f=>`${f}`=="false")?"false":e.join(" && ")||"true"),H=e=>`${e}`=="true"?h("false"):`${e}`=="false"?h("true"):y("!%s",N(e));return Mt={format:y,safe:h,safeand:ne,safenot:H,safenotor:(...e)=>H(Q(...e))},Mt}var Nt,Sr;function Cr(){if(Sr)return Nt;Sr=1;const{safe:s}=wt(),q=new WeakMap;return Nt={scopeMethods:a=>{q.has(a)||q.set(a,{sym:new Map,ref:new Map,format:new Map,pattern:new Map});const y=q.get(a),h=g=>{y.sym.get(g)||y.sym.set(g,0);const e=y.sym.get(g);return y.sym.set(g,e+1),s(`${g}${e}`)},w=g=>{if(y.pattern.has(g))return y.pattern.get(g);const e=h("pattern");return a[e]=new RegExp(g,"u"),y.pattern.set(g,e),e};return y.loop||(y.loop="ijklmnopqrstuvxyz".split("")),{gensym:h,genpattern:w,genloop:()=>{const g=y.loop.shift();return y.loop.push(`${g}${g[0]}`),s(g)},getref:g=>y.ref.get(g),genref:g=>{const e=h("ref");return y.ref.set(g,e),e},genformat:g=>{let e=y.format.get(g);return e||(e=h("format"),a[e]=g,y.format.set(g,e)),e}}}},Nt}var Pt,Ir;function Jt(){if(Ir)return Pt;Ir=1;const s=e=>/[\uD800-\uDFFF]/.test(e)?[...e].length:e.length,q=(e,f,i,c)=>{if(e%f===0)return!0;let l=e*i;if((l===1/0||l===-1/0)&&(l=e),l%c===0)return!0;const b=Math.floor(l+.5);return b/i===e&&b%c===0},E=(e,f)=>{if(e===f)return!0;if(!e||!f||typeof e!=typeof f||e!==f&&typeof e!="object")return!1;const i=Object.getPrototypeOf(e);if(i!==Object.getPrototypeOf(f))return!1;if(i===Array.prototype)return!Array.isArray(e)||!Array.isArray(f)||e.length!==f.length?!1:e.every((c,l)=>E(c,f[l]));if(i===Object.prototype){const[c,l]=[Object.keys(e),Object.keys(f)];return c.length!==l.length?!1:new Set([...c,...l]).size===c.length&&c.every(k=>E(e[k],f[k]))}return!1},a=e=>{if(e.length<2)return!0;if(e.length===2)return!E(e[0],e[1]);const f=[],i=e.length>20?new Set:null;let c=0,l=0;for(const b of e){if(typeof b=="object")f.push(b);else if(i){if(i.add(b),i.size!==++c)return!1}else if(e.indexOf(b,l+1)!==-1)return!1;l++}for(let b=1;b<f.length;b++)for(let k=0;k<b;k++)if(E(f[b],f[k]))return!1;return!0},y=e=>{if(typeof Buffer<"u")return Buffer.from(e,"base64").toString("utf-8");const f=atob(e);return new TextDecoder("utf-8").decode(new Uint8Array(f.length).map((i,c)=>f.charCodeAt(c)))},h=Function.prototype.call.bind(Object.prototype.hasOwnProperty);h[Symbol.for("toJayString")]="Function.prototype.call.bind(Object.prototype.hasOwnProperty)";const w=e=>/~\//.test(e)?`${e}`.replace(/~/g,"~0").replace(/\//g,"~1"):e;return Pt={stringLength:s,isMultipleOf:q,deepEqual:E,unique:a,deBase64:y,hasOwn:h,...{toPointer:e=>e.length===0?"#":`#/${e.map(w).join("/")}`,pointerPart:w,errorMerge:({keywordLocation:e,instanceLocation:f},i,c)=>({keywordLocation:`${i}${e.slice(1)}`,instanceLocation:`${c}${f.slice(1)}`}),propertyIn:(e,[f,i])=>f.includes(!0)||f.some(c=>c===e)||i.some(c=>new RegExp(c,"u").test(e)),dynamicResolve:(e,f)=>(e.filter(i=>i[f])[0]||{})[f]}},Pt}var Dt,Rr;function Ur(){if(Rr)return Dt;Rr=1;const{format:s,safe:q}=wt(),{scopeMethods:E}=Cr(),a=Jt(),y=new Map(Object.entries({null:e=>s("%s === null",e),boolean:e=>s('typeof %s === "boolean"',e),array:e=>s("Array.isArray(%s)",e),object:e=>s('typeof %s === "object" && %s && !Array.isArray(%s)',e,e,e),number:e=>s('typeof %s === "number"',e),integer:e=>s("Number.isInteger(%s)",e),string:e=>s('typeof %s === "string"',e)})),h=({name:e,parent:f,keyval:i,keyname:c})=>{if(e){if(f||i||c)throw new Error("name can be used only stand-alone");return e}if(!f)throw new Error("Can not use property of undefined parent!");const l=h(f);if(i!==void 0){if(c)throw new Error("Can not use key value and name together");if(!["string","number"].includes(typeof i))throw new Error("Invalid property path");return/^[a-z][a-z0-9_]*$/i.test(i)?s("%s.%s",l,q(i)):s("%s[%j]",l,i)}else if(c)return s("%s[%s]",l,c);throw new Error("Unreachable")},w=new Set([].concat(...[Object,Array,String,Number,Boolean].map(e=>Object.getOwnPropertyNames(e.prototype)))),N=(e,f,i,{unmodifiedPrototypes:c,isJSON:l},b)=>{const{gensym:k,genpattern:D,genloop:F}=E(f,i);return{present:j=>{const z=h(j),{parent:R,keyval:T,keyname:X,inKeys:B,checked:te}=j;if(te||B&&l)throw new Error("Unreachable: useless check for undefined");if(B)return s("%s !== undefined",z);if(R&&X){f.hasOwn=a.hasOwn;const re=h(R);return l?s("%s !== undefined && hasOwn(%s, %s)",z,re,X):s("%s in %s && hasOwn(%s, %s)",X,re,re,X)}else if(R&&T!==void 0){if(c&&l&&!w.has(`${T}`))return s("%s !== undefined",z);f.hasOwn=a.hasOwn;const re=h(R);return l?s("%s !== undefined && hasOwn(%s, %j)",z,re,T):s("%j in %s && hasOwn(%s, %j)",T,re,re,T)}throw new Error("Unreachable: present() check without parent")},forObjectKeys:(j,z)=>{const R=k("key");e.block(s("for (const %s of Object.keys(%s))",R,h(j)),()=>{z(i(j,R,!0),R)})},forArray:(j,z,R)=>{const T=F(),X=h(j);e.block(s("for (let %s = %s; %s < %s.length; %s++)",T,z,T,X,T),()=>{R(i(j,T,c,!0),T)})},patternTest:(j,z)=>{const R=j.replace(/[.^$|*+?(){}[\]\\]/gu,"");if(j===`^${R}$`)return s("(%s === %j)",z,j.slice(1,-1));if(b.has(j))return s("true");if([R,`${R}+`,`${R}.*`,`.*${R}.*`].includes(j))return s("%s.includes(%j)",z,R);if([`^${R}`,`^${R}+`,`^${R}.*`].includes(j))return s("%s.startsWith(%j)",z,R);if([`${R}$`,`.*${R}$`].includes(j))return s("%s.endsWith(%j)",z,R);const T=[...R].slice(0,-1).join("");return[`${R}*`,`${R}?`].includes(j)?T.length===0?s("true"):s("%s.includes(%j)",z,T):[`^${R}*`,`^${R}?`].includes(j)?T.length===0?s("true"):s("%s.startsWith(%j)",z,T):s("%s.test(%s)",D(j),z)},compare:(j,z)=>{if(!z||typeof z!="object")return s("%s === %j",j,z);let R;const T=X=>X.length<=3&&X.every(B=>!B||typeof B!="object");if(Array.isArray(z)){if(R=y.get("array")(j),T(z)){let X=s("%s.length === %d",j,z.length);for(let B=0;B<z.length;B++)X=s("%s && %s[%d] === %j",X,j,B,z[B]);return s("%s && %s",R,X)}}else{R=y.get("object")(j);const[X,B]=[Object.keys(z),Object.values(z)];if(T(B)){let te=s("Object.keys(%s).length === %d",j,X.length);X.length>0&&(f.hasOwn=a.hasOwn);for(const re of X)te=s("%s && hasOwn(%s, %j)",te,j,re);for(const re of X)te=s("%s && %s[%j] === %j",te,j,re,z[re]);return s("%s && %s",R,te)}}return f.deepEqual=a.deepEqual,s("%s && deepEqual(%s, %j)",R,j,z)},propvar:i}},Q=/^\([^)]*\) *=>/,ne=/^[^=]*=>/,H=Symbol.for("toJayString");function g(e){if(typeof e=="function"){if(e[H])return e[H];if(Object.getPrototypeOf(e)!==Function.prototype)throw new Error("Can not stringify: a function with unexpected prototype");const f=`${e}`;if(e.prototype){if(!/^function[ (]/.test(f))throw new Error("Unexpected function");return f}if(Q.test(f)||ne.test(f))return f;throw new Error("Can not stringify: only either normal or arrow functions are supported")}else if(typeof e=="object"){const f=Object.getPrototypeOf(e);if(e instanceof RegExp&&f===RegExp.prototype)return s("%r",e);throw new Error("Can not stringify: an object with unexpected prototype")}throw new Error(`Can not stringify: unknown type ${typeof e}`)}return Dt={types:y,buildName:h,jsHelpers:N,jaystring:g},Dt}var _t,Ar;function Fr(){if(Ar)return _t;Ar=1;const{format:s,safe:q,safenot:E}=wt(),{jaystring:a}=Ur(),y=/[{[]/,h=/[}\]]/;return _t=()=>{const w=[];let N=0;const Q=g=>{h.test(g.trim()[0])&&N--,w.push({indent:N,code:g}),y.test(g[g.length-1])&&N++},ne=()=>{if(N!==0)throw new Error("Unexpected indent at build()");const g=w.map(e=>s("%w%s",e.indent*2,e.code)).join(`
`);return/^[a-z][a-z0-9]*$/i.test(g)?`return ${g}`:`return (${g})`},H=g=>{const e=Object.entries(g);for(const[f,i]of e){if(!/^[a-z][a-z0-9]*$/i.test(f))throw new Error("Unexpected scope key!");if(!(typeof i=="function"||i instanceof RegExp))throw new Error("Unexpected scope value!")}return e};return{optimizedOut:!1,size:()=>w.length,write(g,...e){if(typeof g!="string")throw new Error("Format must be a string!");if(g.includes(`
`))throw new Error("Only single lines are supported");return Q(s(g,...e)),!0},block(g,e,f=!1){const i=N;this.write("%s {",g);const c=w.length;if(e(),c===w.length)return w.pop(),N=i,!1;if(c===w.length-1&&!f){const{code:l}=w[w.length-1];if(!/^(if|for) /.test(l))return w.length-=2,N=i,this.write("%s %s",g,l)}return this.write("}")},if(g,e,f){`${g}`=="false"?(f&&f(),e&&(this.optimizedOut=!0)):`${g}`=="true"?(e&&e(),f&&(this.optimizedOut=!0)):e&&this.block(s("if (%s)",g),e,!!f)?f&&this.block(s("else"),f):f&&this.if(E(g),f)},makeModule(g={}){return`(function() {
'use strict'
${H(g).map(([f,i])=>`const ${q(f)} = ${a(i)};`).join(`
`)}
${ne()}})()`},makeFunction(g={}){const e=H(g),f=e.map(c=>c[0]),i=e.map(c=>c[1]);return Function(...f,`'use strict'
${ne()}`)(...i)}}},_t}var Ct,zr;function Tr(){if(zr)return Ct;zr=1;const s=["$schema","$vocabulary","id","$id","$anchor","$ref","definitions","$defs","$recursiveRef","$recursiveAnchor","$dynamicAnchor","$dynamicRef","type","required","default","enum","const","not","allOf","anyOf","oneOf","if","then","else","maximum","minimum","exclusiveMaximum","exclusiveMinimum","multipleOf","divisibleBy","items","maxItems","minItems","additionalItems","prefixItems","contains","minContains","maxContains","uniqueItems","maxLength","minLength","format","pattern","contentEncoding","contentMediaType","contentSchema","properties","maxProperties","minProperties","additionalProperties","patternProperties","propertyNames","dependencies","dependentRequired","dependentSchemas","propertyDependencies","unevaluatedProperties","unevaluatedItems","title","description","deprecated","readOnly","writeOnly","examples","$comment","example","discriminator","removeAdditional"],E=["draft/next","draft/2020-12","draft/2019-09","draft-07","draft-06","draft-04","draft-03"].map(w=>`https://json-schema.org/${w}/schema`),a=["core","applicator","validation","meta-data","format","content"],y=["core","applicator","unevaluated","validation","meta-data","format-annotation","format-assertion","content"],h=[...a.map(w=>`https://json-schema.org/draft/2019-09/vocab/${w}`),...y.map(w=>`https://json-schema.org/draft/2020-12/vocab/${w}`)];return Ct={knownKeywords:s,schemaVersions:E,knownVocabularies:h},Ct}var Ut,qr;function Lr(){if(qr)return Ut;qr=1;const{knownKeywords:s}=Tr();function q(l,b,k,D="keys"){if(!l.has(b))return l.set(b,k);if(l.get(b)!==k)throw new Error(`Conflicting duplicate ${D}: ${b}`)}function E(l){return l.includes("~")?l.replace(/~[01]/g,b=>{switch(b){case"~1":return"/";case"~0":return"~"}throw new Error("Unreachable")}):l}function a(l,b,k){if(typeof l!="object")throw new Error("Invalid input object");if(typeof b!="string")throw new Error("Invalid JSON pointer");const D=b.split("/");if(!["","#"].includes(D.shift()))throw new Error("Invalid JSON pointer");if(D.length===0)return l;let F=l;for(const G of D){if(typeof G!="string")throw new Error("Invalid JSON pointer");k&&k.push(F);const x=E(G);if(typeof F!="object"||!Object.prototype.hasOwnProperty.call(F,x))return;F=F[x]}return F}const y=/^https?:\/\//;function h(l,b){if(typeof l!="string"||typeof b!="string")throw new Error("Unexpected path!");if(b.length===0)return l;const k=l.replace(/#.*/,"");return b.startsWith("#")?`${k}${b}`:!k.includes("/")||y.test(b)?b:y.test(k)?`${new URL(b,k)}`:b.startsWith("/")?b:[...k.split("/").slice(0,-1),b].join("/")}function w(l){return l.map(k=>k&&(k.$id||k.id)||"").filter(k=>k&&typeof k=="string").reduce(h,"")}const N=["properties","patternProperties","$defs","definitions"],Q=["const","enum","examples","example","comment"],ne=Symbol("skip");function H(l,b){const k=(D,F=!1)=>{if(!D||typeof D!="object")return;const G=b(D);if(G!==void 0)return G===ne?void 0:G;for(const x of Object.keys(D)){if(!F&&!Array.isArray(D)&&!s.includes(x)||!F&&Q.includes(x))continue;const ie=k(D[x],!F&&N.includes(x));if(ie!==void 0)return ie}};return k(l)}function g(l,b,k,D=""){const F=h(D,k),G=[],[x,ie=""]=F.split("#"),J=decodeURI(ie),we=(j,z,R=!1,T=!1)=>{if(!j||typeof j!="object")return;const X=j.$id||j.id;let B=z;if(X&&typeof X=="string"){if(B=h(B,X),B===F||B===x&&J==="")G.push([j,l,z]);else if(B===x&&J[0]==="/"){const re=[],ot=a(j,J,re);ot!==void 0&&G.push([ot,l,h(z,w(re))])}}const te=T?j.$dynamicAnchor:j.$anchor;if(te&&typeof te=="string"){if(te.includes("#"))throw new Error("$anchor can't include '#'");if(te.startsWith("/"))throw new Error("$anchor can't start with '/'");B=h(B,`#${te}`),B===F&&G.push([j,l,z])}for(const re of Object.keys(j))!R&&!Array.isArray(j)&&!s.includes(re)||!R&&Q.includes(re)||we(j[re],B,!R&&N.includes(re));!T&&j.$dynamicAnchor&&we(j,z,R,!0)};if(we(l,x),x===D.replace(/#$/,"")&&(J[0]==="/"||J==="")){const j=[],z=a(l,J,j);z!==void 0&&G.push([z,l,w(j)])}if(b.has(x)&&b.get(x)!==l){const j=g(b.get(x),b,`#${ie}`,x);G.push(...j.map(([z,R,T])=>[z,R,h(x,T)]))}return b.has(F)&&G.push([b.get(F),b.get(F),F]),G}function e(l){const b=new Map;return H(l,k=>{if(k!==l&&(k.$id||k.id))return ne;const D=k.$dynamicAnchor;if(D&&typeof D=="string"){if(D.includes("#"))throw new Error("$dynamicAnchor can't include '#'");if(!/^[a-zA-Z0-9_-]+$/.test(D))throw new Error(`Unsupported $dynamicAnchor: ${D}`);q(b,D,k,"$dynamicAnchor")}}),b}const f=(l,b)=>H(l,k=>Object.keys(k).some(D=>b.includes(D))||void 0)||!1,i=(l,b,k=!1)=>{if(!Array.isArray(b))throw new Error("Expected an array of schemas");for(const D of b)H(D,F=>{const G=F.$id||F.id,x=G&&typeof G=="string"?G.replace(/#$/,""):null;if(x&&x.includes("://")&&!x.includes("#"))q(l,x,F,"schema $id in 'schemas'");else if(F===D&&!k)throw new Error("Schema with missing or invalid $id in 'schemas'")});return l},c=(l,b)=>{if(b)return i(c(l),b,!0);if(l)switch(Object.getPrototypeOf(l)){case Object.prototype:return new Map(Object.entries(l));case Map.prototype:return new Map(l);case Array.prototype:return i(new Map,l)}throw new Error("Unexpected value for 'schemas' option")};return Ut={get:a,joinPath:h,resolveReference:g,getDynamicAnchors:e,hasKeywords:f,buildSchemas:c},Ut}var Ft,Mr;function Yn(){if(Mr)return Ft;Mr=1;const s={email:a=>{if(a.length>318)return!1;if(/^[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,20}(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,21}){0,2}@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,60}[a-z0-9])?){0,3}$/i.test(a))return!0;if(!a.includes("@")||/(^\.|^"|\.@|\.\.)/.test(a))return!1;const[h,w,...N]=a.split("@");return!h||!w||N.length!==0||h.length>64||w.length>253||!/^[a-z0-9.-]+$/i.test(w)||!/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(h)?!1:w.split(".").every(Q=>/^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(Q))},hostname:a=>a.length>(a.endsWith(".")?254:253)?!1:/^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*\.?$/i.test(a),date:a=>{if(a.length!==10)return!1;if(a[5]==="0"&&a[6]==="2"){if(/^\d\d\d\d-02-(?:[012][1-8]|[12]0|[01]9)$/.test(a))return!0;const y=a.match(/^(\d\d\d\d)-02-29$/);if(!y)return!1;const h=y[1]|0;return h%16===0||h%4===0&&h%25!==0}return a.endsWith("31")?/^\d\d\d\d-(?:0[13578]|1[02])-31$/.test(a):/^\d\d\d\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)$/.test(a)},time:a=>{if(a.length>27||!/^(?:2[0-3]|[0-1]\d):[0-5]\d:(?:[0-5]\d|60)(?:\.\d+)?(?:z|[+-](?:2[0-3]|[0-1]\d)(?::?[0-5]\d)?)?$/i.test(a))return!1;if(!/:60/.test(a))return!0;const h=a.match(/([0-9.]+|[^0-9.])/g);let w=Number(h[0])*60+Number(h[2]);return h[5]==="+"?w+=1440-Number(h[6]||0)*60-Number(h[8]||0):h[5]==="-"&&(w+=Number(h[6]||0)*60+Number(h[8]||0)),w%1440===1439},"date-time":a=>{if(a.length>38)return!1;const y=/^\d\d\d\d-(?:0[1-9]|1[0-2])-(?:[0-2]\d|3[01])[t\s](?:2[0-3]|[0-1]\d):[0-5]\d:(?:[0-5]\d|60)(?:\.\d+)?(?:z|[+-](?:2[0-3]|[0-1]\d)(?::?[0-5]\d)?)$/i,h=a[5]==="0"&&a[6]==="2";if(h&&a[8]==="3"||!y.test(a))return!1;if(a[17]==="6"){const w=a.slice(11).match(/([0-9.]+|[^0-9.])/g);let N=Number(w[0])*60+Number(w[2]);if(w[5]==="+"?N+=1440-Number(w[6]||0)*60-Number(w[8]||0):w[5]==="-"&&(N+=Number(w[6]||0)*60+Number(w[8]||0)),N%1440!==1439)return!1}if(h){if(/^\d\d\d\d-02-(?:[012][1-8]|[12]0|[01]9)/.test(a))return!0;const w=a.match(/^(\d\d\d\d)-02-29/);if(!w)return!1;const N=w[1]|0;return N%16===0||N%4===0&&N%25!==0}return a[8]==="3"&&a[9]==="1"?/^\d\d\d\d-(?:0[13578]|1[02])-31/.test(a):/^\d\d\d\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)/.test(a)},ipv4:a=>a.length<=15&&/^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)$/.test(a),ipv6:a=>{if(a.length>45||a.length<2)return!1;let y=0,h=0,w=0,N=!1,Q=!1,ne=0,H=!0;for(let e=0;e<a.length;e++){const f=a.charCodeAt(e);if(e===1&&ne===58&&f!==58)return!1;if(f>=48&&f<=57){if(++w>4)return!1}else if(f===46){if(y>6||h>=3||w===0||Q)return!1;h++,w=0}else if(f===58){if(h>0||y>=7)return!1;if(ne===58){if(N)return!1;N=!0}else e===0&&(H=!1);y++,w=0,Q=!1}else if(f>=97&&f<=102||f>=65&&f<=70){if(h>0||++w>4)return!1;Q=!0}else return!1;ne=f}if(y<2||h>0&&(h!==3||w===0))return!1;if(N&&a.length===2)return!0;if(h>0&&!/(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}$/.test(a))return!1;const g=h>0?6:7;return N?(H||w>0)&&y<g:y===g&&H&&w>0},uri:/^[a-z][a-z0-9+\-.]*:(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/?(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,"uri-reference":/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/?(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)?(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,"uri-template":/^(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2}|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,"json-pointer":/^(?:|\/(?:[^~]|~0|~1)*)$/,"relative-json-pointer":/^(?:0|[1-9][0-9]*)(?:|#|\/(?:[^~]|~0|~1)*)$/,uuid:/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,duration:a=>a.length>1&&a.length<80&&(/^P\d+([.,]\d+)?W$/.test(a)||/^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(a)&&/^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(a))},q={alpha:/^[a-zA-Z]+$/,alphanumeric:/^[a-zA-Z0-9]+$/,"hex-digits":/^[0-9a-f]+$/i,"hex-digits-prefixed":/^0x[0-9a-f]+$/i,"hex-bytes":/^([0-9a-f][0-9a-f])+$/i,"hex-bytes-prefixed":/^0x([0-9a-f][0-9a-f])+$/i,base64:a=>a.length%4===0&&/^[a-z0-9+/]*={0,3}$/i.test(a),"json-pointer-uri-fragment":/^#(|\/(\/|[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)$/i,"host-name":s.hostname,"ip-address":s.ipv4,color:/^(#[0-9A-Fa-f]{3,6}|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|rgb\(\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*,\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*,\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*\)|rgb\(\s*(\d?\d%|100%)\s*,\s*(\d?\d%|100%)\s*,\s*(\d?\d%|100%)\s*\))$/};return Ft={core:s,extra:q,weak:{regex:a=>{if(a.length>1e5||/[^\\]\\Z/.test(a))return!1;try{return new RegExp(a,"u"),!0}catch{return!1}}}},Ft}var Tt,Nr;function Xn(){if(Nr)return Tt;Nr=1;const s=(i,c)=>[...new Set([...i,...c])].sort(),q=(i,c)=>i.filter(l=>c.includes(l)),E=i=>(...c)=>i(...c.map(h)),a=i=>(...c)=>h(i(...c.map(h))),y=(i,c)=>i&&!i.includes(c),h=({type:i=null,dyn:c={},...l})=>({type:i&&[...i].sort(),items:y(i,"array")?1/0:l.items||0,properties:y(i,"object")?[!0]:[...l.properties||[]].sort(),patterns:y(i,"object")?[]:[...l.patterns||[]].sort(),required:y(i,"object")?[]:[...l.required||[]].sort(),fullstring:y(i,"string")||l.fullstring||!1,dyn:{item:y(i,"array")?!1:c.item||!1,items:y(i,"array")?0:Math.max(l.items||0,c.items||0),properties:y(i,"object")?[]:s(l.properties||[],c.properties||[]),patterns:y(i,"object")?[]:s(l.patterns||[],c.patterns||[])},unknown:l.unknown&&!(y(i,"object")&&y(i,"array"))||!1}),w=()=>h({}),N=a((i,c)=>({type:i.type&&c.type?q(i.type,c.type):i.type||c.type||null,items:Math.max(i.items,c.items),properties:s(i.properties,c.properties),patterns:s(i.patterns,c.patterns),required:s(i.required,c.required),fullstring:i.fullstring||c.fullstring,dyn:{item:i.dyn.item||c.dyn.item,items:Math.max(i.dyn.items,c.dyn.items),properties:s(i.dyn.properties,c.dyn.properties),patterns:s(i.dyn.patterns,c.dyn.patterns)},unknown:i.unknown||c.unknown})),Q=(i,c)=>c!==!0&&new RegExp(i,"u").test(c),ne=({properties:i,patterns:c},{properties:l,patterns:b})=>{const k=i.filter(x=>l.includes(x)||l.includes(!0)||b.some(ie=>Q(ie,x))),D=l.filter(x=>i.includes(x)||i.includes(!0)||c.some(ie=>Q(ie,x))),F=c.filter(x=>b.includes(x)||l.includes(!0)),G=b.filter(x=>c.includes(x)||i.includes(!0));return{properties:s(k,D),patterns:s(F,G)}},H=({properties:i,patterns:c},{properties:l,patterns:b})=>l.every(k=>i.includes(k)||i.includes(!0)||c.some(D=>Q(D,k)))&&b.every(k=>c.includes(k)||i.includes(!0)),g=a((i,c)=>({type:i.type&&c.type?s(i.type,c.type):null,items:Math.min(i.items,c.items),...ne(i,c),required:y(i.type,"object")&&c.required||y(c.type,"object")&&i.required||q(i.required,c.required),fullstring:i.fullstring&&c.fullstring,dyn:{item:i.dyn.item||c.dyn.item,items:Math.max(i.dyn.items,c.dyn.items),properties:s(i.dyn.properties,c.dyn.properties),patterns:s(i.dyn.patterns,c.dyn.patterns)},unknown:i.unknown||c.unknown})),e=(i,c)=>Object.assign(i,N(i,c)),f=E(({unknown:i,items:c,dyn:l,...b})=>({items:c!==1/0&&(i||l.items>c||l.item),properties:!b.properties.includes(!0)&&(i||!H(b,l))}));return Tt={initTracing:w,andDelta:N,orDelta:g,applyDelta:e,isDynamic:f,inProperties:H},Tt}var Lt,Pr;function Qn(){if(Pr)return Lt;Pr=1;const{format:s,safe:q,safeand:E,safenot:a,safenotor:y}=wt(),h=Fr(),{resolveReference:w,joinPath:N,getDynamicAnchors:Q,hasKeywords:ne}=Lr(),H=Yn(),{toPointer:g,...e}=Jt(),{scopeMethods:f}=Cr(),{buildName:i,types:c,jsHelpers:l}=Ur(),{knownKeywords:b,schemaVersions:k,knownVocabularies:D}=Tr(),{initTracing:F,andDelta:G,orDelta:x,applyDelta:ie,isDynamic:J,inProperties:we}=Xn(),j=new Set(["^[\\s\\S]*$","^[\\S\\s]*$","^[^]*$","",".*","^","$"]),z=["null","boolean","number","integer","string"],R=new Map(Object.entries({boolean:$=>typeof $=="boolean",array:$=>Array.isArray($)&&Object.getPrototypeOf($)===Array.prototype,object:$=>$&&Object.getPrototypeOf($)===Object.prototype,finite:$=>Number.isFinite($),natural:$=>Number.isInteger($)&&$>=0,string:$=>typeof $=="string",jsonval:$=>e.deepEqual($,JSON.parse(JSON.stringify($)))})),T=R.get("object"),X=$=>T($)||typeof $=="boolean",B=$=>e.deepEqual($,{type:[]}),te=($,L)=>k.indexOf($)>k.indexOf(`https://json-schema.org/${L}/schema`),re=($,L)=>{const A=`${$}`.replace(/^http:\/\//,"https://").replace(/#$/,"");return k.includes(A)?te(A,L):!0},ot=($,L,A=!1,V=!1)=>Object.freeze({parent:$,keyname:L,inKeys:A,number:V}),Wr=($,L,A=!1)=>Object.freeze({parent:$,keyval:L,checked:A}),bt=Symbol("evaluatedStatic"),Ee=Symbol("optDynamic"),Ue=Symbol("optDynAnchors"),Qe=Symbol("optRecAnchors"),Jr=$=>{if(typeof $=="boolean")return $;if(T($)&&Object.keys($).length===0)return!0},Se=new Set,Be=new Map,Kr=($,L,A,V)=>{if(L){const ae=L.replace(/^http:\/\//,"https://").replace(/#$/,"");A(k.includes(ae),"Unexpected schema version:",ae),Be.set($,{exclusiveRefs:te(ae,"draft/2019-09"),contentValidation:te(ae,"draft/2019-09"),dependentUnsupported:te(ae,"draft/2019-09"),newItemsSyntax:!te(ae,"draft/2020-12"),containsEvaluates:!te(ae,"draft/2020-12"),objectContains:!te(ae,"draft/next"),bookending:te(ae,"draft/next")})}else A(!V,"[requireSchema] $schema is required"),Be.set($,{})},Kt=($,L,A,V,ae="")=>{const{mode:je="default",useDefaults:Ht=!1,removeAdditional:Fe=!1,includeErrors:ye=!1,allErrors:de=!1,contentValidation:Zt,dryRun:as,lint:et=!1,allowUnusedKeywords:Ne=A.mode==="lax"||A.mode==="spec",allowUnreachable:Hr=A.mode==="lax"||A.mode==="spec",requireSchema:vt=A.mode==="strong",requireValidation:ct=A.mode==="strong",requireStringValidation:ft=A.mode==="strong",forbidNoopValues:Zr=A.mode==="strong",complexityChecks:Gt=A.mode==="strong",unmodifiedPrototypes:Gr=!1,isJSON:Yt=!1,$schemaDefault:Xt=null,formatAssertion:Qt=A.mode!=="spec"||re(L.$schema,"draft/2019-09"),formats:Bt={},weakFormats:er=A.mode!=="strong",extraFormats:Yr=!1,schemas:Te,...tr}=A,Xr={...H.core,...er?H.weak:{},...Yr?H.extra:{},...Bt};if(Object.keys(tr).length!==0)throw new Error(`Unknown options: ${Object.keys(tr).join(", ")}`);if(!["strong","lax","default","spec"].includes(je))throw new Error(`Invalid mode: ${je}`);if(!ye&&de)throw new Error("allErrors requires includeErrors to be enabled");if(vt&&Xt)throw new Error("requireSchema forbids $schemaDefault");if(je==="strong"){const le={...{requireValidation:ct,requireStringValidation:ft},formatAssertion:Qt,complexityChecks:Gt,requireSchema:vt},S={weakFormats:er,allowUnusedKeywords:Ne};for(const[u,oe]of Object.entries(le))if(!oe)throw new Error(`Strong mode demands ${u}`);for(const[u,oe]of Object.entries(S))if(oe)throw new Error(`Strong mode forbids ${u}`)}const{gensym:he,getref:Qr,genref:Br,genformat:rr}=f(V),en=fe=>{const le=[];let S=fe;for(;S;)S.name||le.unshift(S),S=S.parent||S.errorParent;if(le.every(ge=>ge.keyval!==void 0))return s("%j",g(le.map(ge=>ge.keyval)));const u=["#"],oe=()=>{const ge=u.map(e.pointerPart).join("/");return u.length=0,ge};let be=null;for(const{keyname:ge,keyval:pt,number:De}of le)if(ge){De||(V.pointerPart=e.pointerPart);const Ve=De?ge:s("pointerPart(%s)",ge),C=`${oe()}/`;be=be?s("%s+%j+%s",be,C,Ve):s("%j+%s",C,Ve)}else pt&&u.push(pt);return u.length>0?s("%s+%j",be,`/${oe()}`):be},Oe=Br($);let lt=null;const nr=(...fe)=>{const le=lt(...fe);return nr.errors=lt.errors,le};V[Oe]=nr;const tn=ne($,["$ref","$recursiveRef","$dynamicRef"]),$t=A[Ue]&&tn&&ne($,["$dynamicAnchor"]),rn=()=>A[Ue]?s($t?", dynAnchors = []":", dynAnchors"):s(""),nn=A[Qe]?s(", recursive"):s(""),p=h();p.write("function validate(data%s%s) {",nn,rn()),ye&&p.write("validate.errors = null"),de&&p.write("let errorCount = 0"),A[Ee]&&p.write("validate.evaluatedDynamic = null");let sr=A[Ue]?s(", dynAnchors"):s("");$t&&(p.write("const dynLocal = [{}]"),sr=s(", [...dynAnchors, dynLocal[0] || []]"));const sn=l(p,V,ot,{unmodifiedPrototypes:Gr,isJSON:Yt},j),{present:ke,forObjectKeys:ut,forArray:jt,patternTest:on,compare:Ot}=sn,Pe=[],ce=()=>Be.get(L),Le=ae?[ae]:[],kt=(fe,le,S,u,oe,be={},{constProp:ge}={})=>{const pt=le.length>0&&le[le.length-1].prop===S,De=()=>le.filter(t=>t.prop===S),Ve=!S.parent||S.checked||S.inKeys&&Yt||De().length>0,C=i(S),_e=(...t)=>Wr(S,...t),Ie=({path:t=[],prop:n=S,source:o,suberr:d})=>{const r=g([...oe,...t]),m=ye?en(n):null;if(ye===!0&&fe&&o){V.errorMerge=e.errorMerge;const v=[o,r,m];de?(p.write("if (validate.errors === null) validate.errors = []"),p.write("validate.errors.push(...%s.map(e => errorMerge(e, %j, %s)))",...v)):p.write("validate.errors = [errorMerge(%s[0], %j, %s)]",...v)}else if(ye===!0&&fe){const v=s("{ keywordLocation: %j, instanceLocation: %s }",r,m);de?(p.write("if (%s === null) %s = []",fe,fe),p.write("%s.push(%s)",fe,v)):p.write("%s = [%s]",fe,v)}d&&gr(d),de?p.write("errorCount++"):p.write("return false")},pe=(t,n)=>p.if(t,()=>Ie(n));et&&!V.lintErrors&&(V.lintErrors=[]);const xe=(t,n)=>{const o=n!==void 0?` ${JSON.stringify(n)}`:"",d=N(ae,g(oe)),r=`${t}${o} at ${d}`;if(et)return V.lintErrors.push({message:r,keywordLocation:d,schema:$});throw new Error(r)},Et=(t,n)=>{try{return on(t,n)}catch(o){return xe(o.message),s("false")}},M=(t,...n)=>t||xe(...n),tt=(t,...n)=>M(je==="lax"||je==="spec"||t,...n),Re=(t,n)=>tt(!(u[n]<u[t]),`Invalid ${t} / ${n} combination`),Ae=(t,n="should be specified")=>M(!ct,`[requireValidation] ${t} ${n}`),se=(...t)=>[...oe,...t],We=t=>M(!Fe&&!Ht,`[removeAdditional/useDefaults] uncertain: ${t}`),ir=(t,n)=>M(!Gt,`[complexityChecks] ${t}`,n),or=t=>Kr(L,t||Xt,M,vt),P=F(),W=t=>ie(P,t);if(typeof u=="boolean")return u===!0?(Ae("schema = true","is not allowed"),{stat:P}):(pe(Ve||S.inKeys?!0:ke(S),{}),W({type:[]}),{stat:P});M(T(u),"Schema is not an object");for(const t of Object.keys(u))M(b.includes(t)||Ne,"Keyword not supported:",t);if(Object.keys(u).length===0)return Ae("empty rules node","is not allowed"),{stat:P};const ze=new Set(Object.keys(u)),ar=new Set,qe=(t,...n)=>{M(ar.has(t)||ze.has(t),"Unexpected double consumption:",t),M(e.hasOwn(u,t),"Is not an own property:",t),M(n.every(o=>R.has(o)),"Invalid type used in consume"),M(n.some(o=>R.get(o)(u[t])),"Unexpected type for",t),ze.delete(t)},cr=(t,...n)=>(u[t]!==void 0&&qe(t,...n),u[t]),O=(t,n,o,d={})=>{if(u[t]===void 0)return!1;if(qe(t,...n),o!==null)try{const r=o(u[t]);r!==null&&pe(r,{path:[t],...d})}catch(r){if(et&&!r.message.startsWith("[opt] "))xe(r.message);else throw r}return!0};if(u===L?(or(cr("$schema","string")),O("$vocabulary",["object"],t=>{for(const[n,o]of Object.entries(t))o!==!1&&M(o===!0&&D.includes(n),"Unknown vocabulary:",n);return null})):ce()||or(L.$schema),ce().objectContains)for(const t of["contains","minContains","maxContains"])ar.add(t);O("examples",["array"],null),O("example",["jsonval"],null);for(const t of["title","description","$comment"])O(t,["string"],null);for(const t of["deprecated","readOnly","writeOnly"])O(t,["boolean"],null);O("$defs",["object"],null)||O("definitions",["object"],null);const rt=(t,n,o)=>t===$?q("validate"):Qr(t)||Kt(t,n,A,V,o),Me=()=>Le.length>0?Le[Le.length-1]:"",an=Le.length,fr=t=>(Le.push(N(Me(),t)),null);(!ce().exclusiveRefs||!u.$ref)&&(O("$id",["string"],fr)||O("id",["string"],fr),O("$anchor",["string"],null),O("$dynamicAnchor",["string"],null),(u.$recursiveAnchor||!Zr)&&O("$recursiveAnchor",["boolean"],t=>(t&&Pe.push([u,L,Me()]),null)));const lr=$t&&(u===$||u.id||u.$id);if(lr){const t=Q(u);u!==$&&p.write("dynLocal.unshift({})");for(const[n,o]of t){const d=w(L,Te,`#${n}`,Me()),[r,m,v]=d[0]||[];M(r===o,`Unexpected $dynamicAnchor resolution: ${n}`);const I=rt(r,m,v);p.write("dynLocal[0][%j] = %s",`#${n}`,I)}}const St=t=>A[Ee]&&(u[t]||u[t]===!1||u===$),me=Object.freeze({item:St("unevaluatedItems")?he("evaluatedItem"):null,items:St("unevaluatedItems")?he("evaluatedItems"):null,props:St("unevaluatedProperties")?he("evaluatedProps"):null}),Y=Object.freeze({item:me.item||be.item,items:me.items||be.items,props:me.props||be.props}),ur=()=>(!Y.items||P.items===1/0)&&(!Y.props||P.properties.includes(!0)),ve=t=>{if(Y.item&&t.item&&P.items!==1/0&&p.write("%s.push(%s)",Y.item,t.item),Y.items&&t.items>P.items&&p.write("%s.push(%d)",Y.items,t.items),Y.props&&(t.properties||[]).includes(!0)&&!P.properties.includes(!0))p.write("%s[0].push(true)",Y.props);else if(Y.props){const n=(r,m)=>we(P,{properties:r,patterns:m}),o=(t.properties||[]).filter(r=>!n([r],[])),d=(t.patterns||[]).filter(r=>!n([],[r]));o.length>0&&p.write("%s[0].push(...%j)",Y.props,o),d.length>0&&p.write("%s[1].push(...%j)",Y.props,d);for(const r of t.propertiesVars||[])p.write("%s[0].push(%s)",Y.props,r)}},dr=(t,n,o,d)=>{J(P).items&&t.item&&n&&p.write("%s.push(...%s)",t.item,n),J(P).items&&t.items&&o&&p.write("%s.push(...%s)",t.items,o),J(P).properties&&t.props&&d&&(p.write("%s[0].push(...%s[0])",t.props,d),p.write("%s[1].push(...%s[1])",t.props,d))},cn=()=>A[Qe]?Pe.length===0?s(", recursive"):s(", recursive || %s",rt(...Pe[0])):s(""),mt=(t,n)=>{const o=V[t]&&V[t][bt]||{unknown:!0};W(o);const d=s("%s(%s%s%s)",t,C,cn(),sr);if(!ye&&ur())return s("!%s",d);const r=he("res"),m=he("err"),v=he("suberr");return ye&&p.write("const %s = validate.errors",m),p.write("const %s = %s",r,d),ye&&p.write("const %s = %s.errors",v,t),ye&&p.write("validate.errors = %s",m),pe(a(r),{...n,source:v}),p.if(r,()=>{const I=J(o).items?s("%s.evaluatedDynamic[0]",t):null,_=J(o).items?s("%s.evaluatedDynamic[1]",t):null,U=J(o).properties?s("%s.evaluatedDynamic[2]",t):null;dr(Y,I,_,U)}),null},pr=(t,n)=>t&&t.every(o=>n.includes(o)),mr=(t,n)=>n.some(o=>t===null||t.includes(o)),hr=(...t)=>De().some(n=>pr(n.stat.type,t)),fn=(...t)=>pr(P.type,t)||hr(...t),Je=(...t)=>mr(P.type,t)&&De().every(n=>mr(n.stat.type,t)),It=(t,n=u)=>{M(typeof t=="string","Invalid pattern:",t),(ct||ft)&&M(/^\^.*\$$/.test(t),"Should start with ^ and end with $:",t),/([{+*].*[{+*]|\)[{+*]|^[^^].*[{+*].)/.test(t)&&n.maxLength===void 0&&ir("maxLength should be specified for pattern:",t)},ln=u.pattern&&!j.has(u.pattern),un=u.uniqueItems||ln||u.patternProperties||u.format,ht=de&&un?he("prev"):null,yt=(t,n)=>p.if(t&&ht!==null?s("errorCount === %s",ht):!0,n),yr=()=>[...le,{stat:P,prop:S}],ue=(...t)=>kt(fe,yr(),...t).stat,Ce=(t,...n)=>{if(n[0]===S){const r=Jr(n[1]);if(r===!0)return{sub:s("true"),delta:{}};if(r===!1)return{sub:s("false"),delta:{type:[]}}}const o=he("sub");p.write("const %s = (() => {",o),de&&p.write("let errorCount = 0");const{stat:d}=kt(t,yr(),...n);return de?p.write("return errorCount === 0"):p.write("return true"),p.write("})()"),{sub:o,delta:d}},Rt=()=>{const t=ye&&de?he("suberr"):null;return t&&p.write("let %s = null",t),t},gr=t=>{fe===null||t===null||p.if(t,()=>p.write("%s.push(...%s)",fe,t))},wr=()=>{if(!Fe)return!1;if(Fe===!0)return!0;if(Fe==="keyword")return u.removeAdditional?(qe("removeAdditional","boolean"),!0):!1;throw new Error(`Invalid removeAdditional: ${Fe}`)},gt=(t,n,o)=>{O(t,["object","boolean"],r=>r===!1&&wr()?(p.write("if (%s.length > %s) %s.length = %s",C,n,C,n),null):r===!1&&!o?s("%s.length > %s",C,n):(jt(S,n,(m,v)=>(o&&p.write("if (%s) continue",o(v)),ue(m,r,se(t)))),null))&&W({items:1/0})},At=(t,n)=>{O(t,["object","boolean"],d=>(ut(S,(r,m)=>{p.if(n(m),()=>{d===!1&&wr()?p.write("delete %s[%s]",C,m):ue(r,d,se(t))})}),null))&&W({properties:[!0]})},br=(t,n,o)=>E(...n.map(d=>s("%s !== %j",t,d)),...o.map(d=>a(Et(d,t)))),vr=(t,n)=>{const o=n.map(r=>new RegExp(r,"u")),d=r=>t.includes(r)||o.some(m=>m.test(r));for(const r of P.required)M(d(r),"Unknown required property:",r)},$r=[],dn=()=>{const t=(o,d)=>s("!(%d %c %s)",o,d,C);Number.isFinite(u.exclusiveMinimum)?O("exclusiveMinimum",["finite"],o=>t(o,"<")):(O("minimum",["finite"],o=>t(o,u.exclusiveMinimum?"<":"<=")),O("exclusiveMinimum",["boolean"],null)),Number.isFinite(u.exclusiveMaximum)?(O("exclusiveMaximum",["finite"],o=>t(o,">")),Re("minimum","exclusiveMaximum"),Re("exclusiveMinimum","exclusiveMaximum")):u.maximum!==void 0&&(O("maximum",["finite"],o=>t(o,u.exclusiveMaximum?">":">=")),O("exclusiveMaximum",["boolean"],null),Re("minimum","maximum"),Re("exclusiveMinimum","maximum"));const n=u.multipleOf===void 0?"divisibleBy":"multipleOf";O(n,["finite"],o=>{M(o>0,`Invalid ${n}:`,o);const[d,r]=`${o}`.split("e-"),v=`${d}.`.split(".")[1].length+(r?Number(r):0);if(Number.isInteger(o*2**v))return s("%s %% %d !== 0",C,o);V.isMultipleOf=e.isMultipleOf;const I=[C,o,v,Math.round(o*Math.pow(10,v))];return s("!isMultipleOf(%s, %d, 1e%d, %d)",...I)})},pn=()=>{O("maxLength",["natural"],t=>(V.stringLength=e.stringLength,s("%s.length > %d && stringLength(%s) > %d",C,t,C,t))),O("minLength",["natural"],t=>(V.stringLength=e.stringLength,s("%s.length < %d || stringLength(%s) < %d",C,t,C,t))),Re("minLength","maxLength"),yt(!0,()=>{const t=(r,m,v=Xr)=>{const I=typeof r=="string"&&e.hasOwn(v,r);M(I,"Unrecognized format used:",r);const _=v[r],U=_ instanceof RegExp||typeof _=="function";return M(U,"Invalid format used:",r),Qt?_ instanceof RegExp?(e.hasOwn(Bt,r)&&It(_.source),s("!%s.test(%s)",rr(_),m)):s("!%s(%s)",rr(_),m):null};O("format",["string"],r=>(W({fullstring:!0}),t(r,C))),O("pattern",["string"],r=>(It(r),W({fullstring:!0}),j.has(r)?null:a(Et(r,C)))),M(u.contentSchema!==!1,"contentSchema cannot be set to false");const n=Zt===void 0?ce().contentValidation:Zt,o=u.contentEncoding||u.contentMediaType||u.contentSchema;if(M(!o||n||Ne,'"content*" keywords are disabled by default per spec, enable with { contentValidation = true } option (see doc/Options.md for more info)'),o&&n){const r=he("dec");u.contentMediaType&&p.write("let %s = %s",r,C),u.contentEncoding==="base64"?(pe(t("base64",C,H.extra),{path:["contentEncoding"]}),u.contentMediaType&&(V.deBase64=e.deBase64,p.write("try {"),p.write("%s = deBase64(%s)",r,r)),qe("contentEncoding","string")):M(!u.contentEncoding,"Unknown contentEncoding:",u.contentEncoding);let m=!1;if(u.contentMediaType==="application/json"?(p.write("try {"),p.write("%s = JSON.parse(%s)",r,r),m=!0,qe("contentMediaType","string")):M(!u.contentMediaType,"Unknown contentMediaType:",u.contentMediaType),u.contentSchema){M(m,"contentSchema requires contentMediaType application/json");const v=Object.freeze({name:r,errorParent:S});ue(v,u.contentSchema,se("contentSchema")),qe("contentSchema","object","array"),W({fullstring:!0})}u.contentMediaType&&(p.write("} catch (e) {"),Ie({path:["contentMediaType"]}),p.write("}"),u.contentEncoding&&(p.write("} catch (e) {"),Ie({path:["contentEncoding"]}),p.write("}")))}})},mn=()=>{O("maxItems",["natural"],r=>{const m=ce().newItemsSyntax?"prefixItems":"items";return Array.isArray(u[m])&&u[m].length>r&&xe(`Invalid maxItems: ${r} is less than ${m} array length`),s("%s.length > %d",C,r)}),O("minItems",["natural"],r=>s("%s.length < %d",C,r)),Re("minItems","maxItems");const t=r=>{for(let m=0;m<r.length;m++)ue(_e(m),r[m],se(`${m}`));return W({items:r.length}),null};ce().newItemsSyntax?(O("prefixItems",["array"],t),gt("items",s("%d",(u.prefixItems||[]).length))):Array.isArray(u.items)?(O("items",["array"],t),gt("additionalItems",s("%d",u.items.length))):O("items",["object","boolean"],r=>(jt(S,s("0"),m=>ue(m,r,se("items"))),W({items:1/0}),null)),jr(r=>{jt(S,s("0"),(m,v)=>{r(m,()=>{W({dyn:{item:!0}}),ve({item:v})})})});const n=r=>{if(!T(r))return!1;if(r.enum||e.hasOwn(r,"const")||r.type&&(Array.isArray(r.type)?r.type:[r.type]).every(v=>z.includes(v)))return!0;if(r.$ref){const[m]=w(L,Te,r.$ref,Me())[0]||[];if(n(m))return!0}return!1},o=r=>r===!1||n(r),d=()=>!!(u.maxItems!==void 0||o(u.items)||Array.isArray(u.items)&&o(u.additionalItems));yt(!0,()=>{O("uniqueItems",["boolean"],r=>r===!1?null:(d()||ir("maxItems should be specified for non-primitive uniqueItems"),Object.assign(V,{unique:e.unique,deepEqual:e.deepEqual}),s("!unique(%s)",C)))})},Ke=t=>!de&&(P.required.includes(t)||De().some(n=>n.stat.required.includes(t))),hn=()=>{const t=s("Object.keys(%s).length",C);O("maxProperties",["natural"],n=>s("%s > %d",t,n)),O("minProperties",["natural"],n=>s("%s < %d",t,n)),Re("minProperties","maxProperties"),O("propertyNames",["object","boolean"],n=>(ut(S,(o,d)=>{const r=typeof n=="object"&&!n.$ref?{type:"string",...n}:n,m=Object.freeze({name:d,errorParent:o,type:"string"});ue(m,r,se("propertyNames"))}),null)),O("required",["array"],n=>{for(const o of n){if(Ke(o))continue;const d=_e(o);pe(a(ke(d)),{path:["required"],prop:d})}return W({required:n}),null});for(const n of["dependencies","dependentRequired","dependentSchemas"])n!=="dependencies"&&ce().dependentUnsupported||O(n,["object"],o=>{for(const d of Object.keys(o)){const r=typeof o[d]=="string"?[o[d]]:o[d],m=_e(d,Ke(d));if(Array.isArray(r)&&n!=="dependentSchemas"){const v=r.filter(U=>!Ke(U)).map(U=>ke(_e(U))),I=a(E(...v)),_={path:[n,d]};v.length===0||(m.checked?(pe(I,_),W({required:r})):pe(E(ke(m),I),_))}else X(r)&&n!=="dependentRequired"?(We(n),p.if(m.checked?!0:ke(m),()=>{const v=ue(S,r,se(n,d),Y);W(x({},v)),ve(v)})):xe(`Unexpected ${n} entry`)}return null});O("propertyDependencies",["object"],n=>{for(const[o,d]of Object.entries(n)){M(T(d),"propertyDependencies must be an object"),We("propertyDependencies");const r=_e(o,Ke(o));p.if(r.checked?!0:ke(r),()=>{for(const[m,v]of Object.entries(d))M(X(v),"propertyDependencies must contain schemas"),p.if(Ot(i(r),m),()=>{const I=ue(S,v,se("propertyDependencies",o,m),Y);W(x({},I)),ve(I)})})}return null}),O("properties",["object"],n=>{for(const o of Object.keys(n))ge!==o&&ue(_e(o,Ke(o)),n[o],se("properties",o));return W({properties:Object.keys(n)}),null}),yt(u.patternProperties,()=>{if(O("patternProperties",["object"],n=>(ut(S,(o,d)=>{for(const r of Object.keys(n))It(r,u.propertyNames||{}),p.if(Et(r,d),()=>{ue(o,n[r],se("patternProperties",r))})}),W({patterns:Object.keys(n)}),null)),u.additionalProperties||u.additionalProperties===!1){const n=Object.keys(u.properties||{}),o=Object.keys(u.patternProperties||{});u.additionalProperties===!1&&$r.push(()=>vr(n,o)),At("additionalProperties",r=>br(r,n,o))}}),ce().objectContains&&jr(n=>{ut(S,(o,d)=>{n(o,()=>{W({dyn:{properties:[!0]}}),ve({propertiesVars:[d]})})})})},yn=()=>{const t=O("const",["jsonval"],o=>a(Ot(C,o)));if(t&&!Ne)return!0;const n=O("enum",["array"],o=>{const d=o.filter(m=>m&&typeof m=="object"),r=o.filter(m=>!(m&&typeof m=="object"));return y(...[...r,...d].map(m=>Ot(C,m)))});return t||n},jr=t=>{O("contains",["object","boolean"],()=>{We("contains"),ce().objectContains&&Je("array")&&Je("object")&&Ae("possible type confusion in 'contains',","forbid 'object' or 'array'");const n=he("passes");p.write("let %s = 0",n);const o=Rt();return t((d,r)=>{const{sub:m}=Ce(o,d,u.contains,se("contains"));p.if(m,()=>{p.write("%s++",n),ce().containsEvaluates&&(M(!Fe,`Can't use removeAdditional with draft2020+ "contains"`),r())})}),O("minContains",["natural"],d=>s("%s < %d",n,d),{suberr:o})||pe(s("%s < 1",n),{path:["contains"],suberr:o}),O("maxContains",["natural"],d=>s("%s > %d",n,d)),Re("minContains","maxContains"),null})},gn=()=>{O("not",["object","boolean"],r=>Ce(null,S,r,se("not")).sub),u.not&&We("not"),(u.then||u.then===!1||u.else||u.else===!1||Ne)&&O("if",["object","boolean"],r=>{We("if/then/else");const{sub:m,delta:v}=Ce(null,S,r,se("if"),Y);let I,_,U,K;return O("else",["object","boolean"],Z=>(I=()=>{U=ue(S,Z,se("else"),Y),ve(U)},null)),O("then",["object","boolean"],Z=>(_=()=>{K=ue(S,Z,se("then"),Y),ve(G(v,K))},null)),!_&&!B(v)&&(_=()=>ve(v)),p.if(m,_,I),W(x(U||{},G(v,K||{}))),null});const n=(r,m="allOf")=>{M(r.length>0,`${m} cannot be empty`);for(const[v,I]of Object.entries(r))W(ue(S,I,se(m,v),Y));return null};O("allOf",["array"],r=>n(r));let o=null;O("discriminator",["object"],r=>{const m=new Set,v=(ee,Ze,Ge)=>M(ee,`[discriminator]: ${Ze}`,Ge),{propertyName:I,mapping:_,...U}=r,K=_e(I);v(I&&!u.oneOf!=!u.anyOf,"need propertyName, oneOf OR anyOf"),v(Object.keys(U).length===0,'only "propertyName" and "mapping" are supported');const Z=ee=>T(ee)?Object.keys(ee).length:null;return o=(ee,Ze)=>{const Ge=()=>{p.write("switch (%s) {",i(K));let Ye;for(const[vn,Xe]of Object.entries(ee)){const{const:zt,enum:xr,...$n}=(Xe.properties||{})[I]||{};let st=zt!==void 0?[zt]:xr;if(!st&&Xe.$ref){const[$e]=w(L,Te,Xe.$ref,Me())[0]||[];M(T($e),"failed to resolve $ref:",Xe.$ref);const it=($e.properties||{})[I]||{};st=it.const!==void 0?[it.const]:it.enum}const jn=Array.isArray(st)&&st.length>0;v(jn,"branches should have unique string const or enum values for [propertyName]");const On=Object.keys($n).length===0&&(!zt||!xr);v(On,"only const OR enum rules are allowed on [propertyName] in branches");for(const $e of st){const it=!_||e.hasOwn(_,$e)&&_[$e]===Xe.$ref;v(it,"mismatching mapping for",$e);const kn=typeof $e=="string"&&!m.has($e);v(kn,"const/enum values for [propertyName] should be unique strings"),m.add($e),p.write("case %j:",$e)}const qt=ue(S,Xe,se(Ze,vn),Y,{constProp:I});ve(qt),Ye=Ye?x(Ye,qt):qt,p.write("break")}v(_===void 0||Z(_)===m.size,"mismatching mapping size"),W(Ye),p.write("default:"),Ie({path:[Ze]}),p.write("}")},nt=()=>{if(Ke(I))Ge();else{const Ye=["discriminator","propertyName"];p.if(ke(K),Ge,()=>Ie({path:Ye,prop:K}))}};return de||!e.deepEqual(P.type,["object"])?p.if(c.get("object")(C),nt,()=>Ie({path:["discriminator"]})):nt(),v(e.deepEqual(P.type,["object"]),"has to be checked for type:","object"),v(P.required.includes(I),"propertyName should be placed in required:",I),null},null});const d=(r,m)=>{const v=m.map(U=>U.type||(Array.isArray(U.const)?"array":typeof U.const)),I=v.filter(U=>!z.includes(U)&&U!=="array").length,_=v.filter(U=>!z.includes(U)&&U!=="object").length;(I>1||_>1)&&We(`${r}, use discriminator to make it certain`)};O("anyOf",["array"],r=>{if(M(r.length>0,"anyOf cannot be empty"),r.length===1)return n(r);if(o)return o(r,"anyOf");const m=Rt();if(!ur()){d("anyOf",r);const K=Object.entries(r).map(([Z,ee])=>Ce(m,S,ee,se("anyOf",Z),Y));W(K.map(Z=>Z.delta).reduce((Z,ee)=>x(Z,ee))),pe(y(...K.map(({sub:Z})=>Z)),{path:["anyOf"],suberr:m});for(const{delta:Z,sub:ee}of K)p.if(ee,()=>ve(Z));return null}const v=r.filter(K=>e.hasOwn(K,"const")),I=r.filter(K=>!e.hasOwn(K,"const"));d("anyOf",I);const _=[...v,...I];let U;if(ce().exclusiveRefs){let K=()=>Ie({path:["anyOf"],suberr:m});for(const[Z,ee]of Object.entries(_).reverse()){const Ze=K;K=()=>{const{sub:Ge,delta:nt}=Ce(m,S,ee,se("anyOf",Z));p.if(a(Ge),Ze),U=U?x(U,nt):nt}}K()}else{const K=Object.entries(r).map(([Z,ee])=>Ce(m,S,ee,se("anyOf",Z),Y));U=K.map(Z=>Z.delta).reduce((Z,ee)=>x(Z,ee)),pe(y(...K.map(({sub:Z})=>Z)),{path:["anyOf"],suberr:m})}return W(U),null}),O("oneOf",["array"],r=>{if(M(r.length>0,"oneOf cannot be empty"),r.length===1)return n(r);if(o)return o(r,"oneOf");d("oneOf",r);const m=he("passes");p.write("let %s = 0",m);const v=Rt();let I,_=0;const U=Object.entries(r).map(([K,Z])=>{!ye&&_++>1&&pe(s("%s > 1",m),{path:["oneOf"]});const ee=Ce(v,S,Z,se("oneOf",K),Y);return p.if(ee.sub,()=>p.write("%s++",m)),I=I?x(I,ee.delta):ee.delta,ee});W(I),pe(s("%s !== 1",m),{path:["oneOf"]}),p.if(s("%s === 0",m),()=>gr(v));for(const K of U)p.if(K.sub,()=>ve(K.delta));return null})},He=(t,n,o)=>{const[d,r]=[p.size(),ze.size];p.if(fn(...n)?!0:o,t),(d!==p.size()||r!==ze.size)&&M(Je(...n),"Unexpected rules in type",u.type)},wn=()=>{if(P.items===1/0)u.unevaluatedItems===!1&&qe("unevaluatedItems","boolean");else if(u.unevaluatedItems||u.unevaluatedItems===!1)if(J(P).items){if(!A[Ee])throw new Error("[opt] Dynamic unevaluated tracing not enabled");const t=s("Math.max(%d, ...%s)",P.items,Y.items),n=o=>s("%s.includes(%s)",Y.item,o);gt("unevaluatedItems",t,ce().containsEvaluates?n:null)}else gt("unevaluatedItems",s("%d",P.items))},bn=()=>{yt(P.patterns.length>0||P.dyn.patterns.length>0||P.unknown,()=>{if(P.properties.includes(!0))u.unevaluatedProperties===!1&&qe("unevaluatedProperties","boolean");else if(u.unevaluatedProperties||u.unevaluatedProperties===!1){const t=n=>br(n,P.properties,P.patterns);if(J(P).properties){if(!A[Ee])throw new Error("[opt] Dynamic unevaluated tracing not enabled");V.propertyIn=e.propertyIn;const n=d=>s("!propertyIn(%s, %s)",d,Y.props);At("unevaluatedProperties",d=>E(t(d),n(d)))}else u.unevaluatedProperties===!1&&vr(P.properties,P.patterns),At("unevaluatedProperties",t)}})},Or=()=>{if(ht!==null&&p.write("const %s = errorCount",ht),yn()){const t=[...c.keys()];if(W({properties:[!0],items:1/0,type:t,fullstring:!0}),!Ne){M(ze.size===0,"Unexpected keywords mixed with const or enum:",[...ze]);return}}He(dn,["number","integer"],c.get("number")(C)),He(pn,["string"],c.get("string")(C)),He(mn,["array"],c.get("array")(C)),He(hn,["object"],c.get("object")(C)),gn(),He(wn,["array"],c.get("array")(C)),He(bn,["object"],c.get("object")(C));for(const t of $r)t();dr(be,me.item,me.items,me.props)},kr=()=>{if(me.item&&p.write("const %s = []",me.item),me.items&&p.write("const %s = [0]",me.items),me.props&&p.write("const %s = [[], []]",me.props),O("$ref",["string"],n=>{const o=w(L,Te,n,Me()),[d,r,m]=o[0]||[];if(!d&&d!==!1&&(xe("failed to resolve $ref:",n),et))return null;const v=rt(d,r,m),I=d===$?Oe:v;if(!V[I])throw new Error("Unexpected: coherence check failed");if(!V[I][bt]&&d.type){const _=Array.isArray(d.type)?d.type:[d.type];W({type:_}),ct&&(Se.add(I),_.includes("array")&&W({items:1/0}),_.includes("object")&&W({properties:[!0]})),ft&&_.includes("string")&&(Se.add(I),W({fullstring:!0}))}return mt(v,{path:["$ref"]})}),ce().exclusiveRefs&&(M(!A[Ee],"unevaluated* is supported only on draft2019-09 and above"),u.$ref))return;O("$recursiveRef",["string"],n=>{if(!A[Qe])throw new Error("[opt] Recursive anchors are not enabled");M(n==="#",'Behavior of $recursiveRef is defined only for "#"');const o=w(L,Te,"#",Me()),[d,r,m]=o[0];tt(d.$recursiveAnchor,"$recursiveRef without $recursiveAnchor");const v=rt(d,r,m),I=d.$recursiveAnchor?s("(recursive || %s)",v):v;return mt(I,{path:["$recursiveRef"]})}),O("$dynamicRef",["string"],n=>{if(!A[Ue])throw new Error("[opt] Dynamic anchors are not enabled");tt(/^[^#]*#[a-zA-Z0-9_-]+$/.test(n),"Unsupported $dynamicRef format");const o=n.replace(/^[^#]+/,""),d=w(L,Te,n,Me());if(!d[0]&&!ce().bookending){tt(!1,"$dynamicRef bookending resolution failed (even though not required)"),V.dynamicResolve=e.dynamicResolve;const K=s("dynamicResolve(dynAnchors || [], %j)",o);return mt(K,{path:["$dynamicRef"]})}M(d[0],"$dynamicRef bookending resolution failed",n);const[r,m,v]=d[0],I=r.$dynamicAnchor&&`#${r.$dynamicAnchor}`===o;tt(I,"$dynamicRef without $dynamicAnchor in the same scope");const _=rt(r,m,v);V.dynamicResolve=e.dynamicResolve;const U=I?s("(dynamicResolve(dynAnchors || [], %j) || %s)",o,_):_;return mt(U,{path:["$dynamicRef"]})});let t=null;O("type",["string","array"],n=>{const o=Array.isArray(n)?n:[n];for(const r of o)M(typeof r=="string"&&c.has(r),"Unknown type:",r);if(S.type)return M(e.deepEqual(o,[S.type]),"One type allowed:",S.type),W({type:[S.type]}),null;if(hr(...o))return null;const d=o.filter(r=>Je(r));return d.length===0&&xe("No valid types possible"),W({type:o}),t=y(...d.map(r=>c.get(r)(C))),null}),t&&de?p.if(t,()=>Ie({path:["type"]}),Or):(t&&pe(t,{path:["type"]}),Or()),P.items<1/0&&u.maxItems<=P.items&&W({items:1/0})};if(u.default!==void 0&&Ht){Ve&&xe("Can not apply default value here (e.g. at root)");const t=cr("default","jsonval");p.if(ke(S),kr,()=>p.write("%s = %j",C,t))}else O("default",["jsonval"],null),p.if(Ve?!0:ke(S),kr);if(Le.length=an,Pe[0]&&Pe[Pe.length-1][0]===u&&Pe.pop(),lr&&u!==$&&p.write("dynLocal.shift()"),Hr||M(!p.optimizedOut,"some checks are never reachable"),pt){const t=["not","if","then","else"].includes(oe[oe.length-1]),n=["oneOf","anyOf","allOf"].includes(oe[oe.length-2]),o=["dependencies","dependentSchemas"].includes(oe[oe.length-2]),d=["propertyDependencies"].includes(oe[oe.length-3]);M(t||n||o||d,"Unexpected logical path")}else if(!oe.includes("not")&&((!($!==L&&u===$)||Se.has(Oe))&&(Se.delete(Oe),P.type||Ae("type"),Je("array")&&P.items!==1/0&&Ae(u.items?"additionalItems or unevaluatedItems":"items rule"),Je("object")&&!P.properties.includes(!0)&&Ae("additionalProperties or unevaluatedProperties"),!P.fullstring&&ft&&xe("[requireStringValidation] pattern, format or contentSchema should be specified for strings, use pattern: ^[\\s\\S]*$ to opt-out")),typeof u.propertyNames!="object"))for(const n of["additionalProperties","unevaluatedProperties"])u[n]&&Ae(`wild-card ${n}`,"requires propertyNames");return u.properties&&!u.required&&Ae("if properties is used, required"),M(ze.size===0||Ne,"Unprocessed keywords:",[...ze]),{stat:P,local:me}},{stat:xt,local:dt}=kt(s("validate.errors"),[],{name:q("data")},$,[]);if(Se.has(Oe))throw new Error("Unexpected: unvalidated cyclic ref");if(A[Ee]&&(J(xt).items||J(xt).properties)){if(!dt)throw new Error("Failed to trace dynamic properties");p.write("validate.evaluatedDynamic = [%s, %s, %s]",dt.item,dt.items,dt.props)}return de?p.write("return errorCount === 0"):p.write("return true"),p.write("}"),et||(lt=p.makeFunction(V),delete V[Oe],V[Oe]=lt),V[Oe][bt]=xt,Oe},at=($,L)=>{if(!Array.isArray($))throw new Error("Expected an array of schemas");try{const A=Object.create(null),{getref:V}=f(A);Se.clear(),Be.clear();const ae=$.map(je=>V(je)||Kt(je,je,L,A));if(Se.size!==0)throw new Error("Unexpected: not all refs are validated");return{scope:A,refs:ae}}catch(A){if(!L[Ee]&&A.message==="[opt] Dynamic unevaluated tracing not enabled")return at($,{...L,[Ee]:!0});if(!L[Ue]&&A.message==="[opt] Dynamic anchors are not enabled")return at($,{...L,[Ue]:!0});if(!L[Qe]&&A.message==="[opt] Recursive anchors are not enabled")return at($,{...L,[Qe]:!0});throw A}finally{Se.clear(),Be.clear()}};return Lt={compile:at},Lt}var Vt,Dr;function Bn(){if(Dr)return Vt;Dr=1;const s=Fr(),{buildSchemas:q}=Lr(),{compile:E}=Qn(),{deepEqual:a}=Jt(),y=g=>function e(f){if(!a(f,JSON.parse(JSON.stringify(f))))return e.errors=[{instanceLocation:"#",error:"not JSON compatible"}],!1;const i=g(f);return e.errors=g.errors,i},h=g=>e=>a(e,JSON.parse(JSON.stringify(e)))&&g(e),w=(g,{parse:e=!1,multi:f=!1,jsonCheck:i=!1,isJSON:c=!1,schemas:l=[],...b}={})=>{if(i&&c)throw new Error("Can not specify both isJSON and jsonCheck options");if(e&&(i||c))throw new Error("jsonCheck and isJSON options are not applicable in parser mode");const k=e?"strong":"default",D=c||i||e,F=f?g:[g],G={mode:k,...b,schemas:q(l,F),isJSON:D},{scope:x,refs:ie}=E(F,G);if(b.dryRun)return;if(b.lint)return x.lintErrors;const J=s();if(e?x.parseWrap=b.includeErrors?N:Q:i&&(x.deepEqual=a,x.jsonCheckWrap=b.includeErrors?y:h),f){J.write("[");for(const j of ie.slice(0,-1))J.write("%s,",j);ie.length>0&&J.write("%s",ie[ie.length-1]),J.write("]"),e?J.write(".map(parseWrap)"):i&&J.write(".map(jsonCheckWrap)")}else e?J.write("parseWrap(%s)",ie[0]):i?J.write("jsonCheckWrap(%s)",ie[0]):J.write("%s",ie[0]);const we=J.makeFunction(x);return we.toModule=({semi:j=!0}={})=>J.makeModule(x)+(j?";":""),we.toJSON=()=>g,we},N=g=>e=>{if(typeof e!="string")return{valid:!1,error:"Input is not a string"};try{const f=JSON.parse(e);if(!g(f)){const{keywordLocation:i,instanceLocation:c}=g.errors[0];return{valid:!1,error:`JSON validation failed for ${i.slice(i.lastIndexOf("/")+1)} at ${c}`,errors:g.errors}}return{valid:!0,value:f}}catch({message:f}){return{valid:!1,error:f}}},Q=g=>e=>{if(typeof e!="string")return{valid:!1};try{const f=JSON.parse(e);return g(f)?{valid:!0,value:f}:{valid:!1}}catch{return{valid:!1}}};return Vt={validator:w,parser:function(g,{parse:e=!0,...f}={}){if(!e)throw new Error("can not disable parse in parser");return w(g,{parse:e,...f})},lint:function(g,{lint:e=!0,...f}={}){if(!e)throw new Error("can not disable lint option in lint()");return w(g,{lint:e,...f})}},Vt}var es=Bn();function ts(s){let q=!1,E=new WeakRef({});const a=h=>s(q?Tn(h,_r):h,E.deref());let y=Wt(new WeakMap,a);return(h,w)=>(q=h!==w,E.deref()!==w&&(E=new WeakRef(w),y=Wt(new WeakMap,a)),y(h))}function rs(s){const q=new WeakMap,E={},a=Wt(q,y=>s(y,E));return y=>a(y.schema)}function Vr({createSchemaValidator:s,valueToJSON:q}){return{isValid(E,a,y){return typeof E=="boolean"?E:s(E,a)(q(y))}}}function ns(s){return{validateFormValue(q,E){const a=s.createSchemaValidator(q,q);return a(s.valueToJSON(E)),Ln(Vr(s),s.merger(),q,a.errors,E)}}}function ss({createFieldSchemaValidator:s,valueToJSON:q}){return{validateFieldValue(E,a){const y=s(E);return y(q(a)),Vn(E,y.errors,a)}}}function is({factory:s=(h,w)=>es.validator(h,{...Gn,schemas:{[_r]:w}}),createSchemaValidator:q=ts(s),createFieldSchemaValidator:E=rs(s),valueToJSON:a=h=>h,...y}){const h={...y,valueToJSON:a,createSchemaValidator:q,createFieldSchemaValidator:E};return Object.assign(Vr(h),ns(h),ss(h))}var os=En("<!> <pre> </pre>",1);function xs(s,q){xn(q,!0);const E=Un({...Wn,schema:Hn,uiSchema:Kn,validator:is,fieldsValidationMode:Dn|_n|Cn,initialValue:Jn});var a=os(),y=Sn(a);Fn(y,{get form(){return E},novalidate:!0});var h=zn(y,2),w=Mn(h,!0);Nn(h),In(N=>qn(w,N),[()=>JSON.stringify(Pn(E),null,2)]),Rn(s,a),An()}export{xs as default};
