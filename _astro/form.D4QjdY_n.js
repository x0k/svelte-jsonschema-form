import"./_commonjsHelpers.CZ9QTLBo.js";import"./legacy.CqgPFLOp.js";import{p as xn,f as En,h as Sn,t as In,b as Rn,a as An,s as zn,d as qn,j as Mn,c as Nn,r as Pn}from"./render.Csu2Zda4.js";import{i as Dn}from"./lifecycle.BQEV1y0f.js";import{Z as Cr,$ as Wt,O as _n,a as Cn,b as Un}from"./definitions.RTWm56Iy.js";import{c as Fn}from"./index.COnu-gdG.js";import{B as Tn}from"./basic-form.BL-xBPBO.js";import{p as Ln}from"./validator.lqhzlNF0.js";import{c as Vn,t as Wn}from"./errors.BGeXodQQ.js";import{d as Jn}from"./form-defaults.CRw_oOlu.js";import{i as Kn,s as Hn,u as Er}from"./index.BPQVTpeN.js";import"./function.CCmB4gZO.js";import"./snippet.CIUK1E-a.js";import"./form.Cc0-sOrI.js";import"./content.B9MdKQj3.js";import"./submit-button.DqyiyCr5.js";import"./path.o33jrVaz.js";import"./model.DdUetptA.js";import"./file-include.DjHeW_j1.js";import"./textarea-include.CDqY708f.js";const Zn={"data-url":/^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/},Gn={includeErrors:!0,allErrors:!0,$schemaDefault:"http://json-schema.org/draft-07/schema",extraFormats:!0,formats:Zn};var Mt,Sr;function wt(){if(Sr)return Mt;Sr=1;class s extends String{}const P=new Set(["<",">","<=",">="]),E=e=>`\\u${e.toString(16).padStart(4,"0")}`,c=e=>{if([1/0,-1/0,NaN,void 0,null].includes(e))return`${e}`;if(!["string","boolean","number"].includes(typeof e)){if(typeof e!="object")throw new Error("Unexpected value type");const i=Object.getPrototypeOf(e);if(!(i===Array.prototype&&Array.isArray(e)||i===Object.prototype))throw new Error("Unexpected object given as value")}return JSON.stringify(e).replace(/([{,])"__proto__":/g,'$1["__proto__"]:').replace(/[^\\]"__proto__":/g,()=>{throw new Error("Unreachable")}).replace(/[\u2028\u2029]/g,i=>E(i.charCodeAt(0)))},m=(e,...f)=>{const i=e.replace(/%[%drscjw]/g,a=>{if(a==="%%")return"%";if(f.length===0)throw new Error("Unexpected arguments count");const l=f.shift();switch(a){case"%d":if(typeof l=="number")return l;throw new Error("Expected a number");case"%r":if(l instanceof RegExp)return m("new RegExp(%j, %j)",l.source,l.flags);throw new Error("Expected a RegExp instance");case"%s":if(l instanceof s)return l;throw new Error("Expected a safe string");case"%c":if(P.has(l))return l;throw new Error("Expected a compare op");case"%j":return c(l);case"%w":if(Number.isInteger(l)&&l>=0)return" ".repeat(l);throw new Error("Expected a non-negative integer for indentation")}throw new Error("Unreachable")});if(f.length!==0)throw new Error("Unexpected arguments count");return new s(i)},y=e=>{if(!/^[a-z][a-z0-9_]*$/i.test(e))throw new Error("Does not look like a safe id");return new s(e)},w=e=>(...f)=>{if(!f.every(i=>i instanceof s))throw new Error("Unsafe arguments");return new s(e(...f))},M=e=>/^[a-z][a-z0-9_().]*$/i.test(e)||/^\([^()]+\)$/i.test(e)?e:m("(%s)",e),G=w((...e)=>e.some(f=>`${f}`=="true")?"true":e.join(" || ")||"false"),ne=w((...e)=>e.some(f=>`${f}`=="false")?"false":e.join(" && ")||"true"),H=e=>`${e}`=="true"?y("false"):`${e}`=="false"?y("true"):m("!%s",M(e));return Mt={format:m,safe:y,safeand:ne,safenot:H,safenotor:(...e)=>H(G(...e))},Mt}var Nt,Ir;function Ur(){if(Ir)return Nt;Ir=1;const{safe:s}=wt(),P=new WeakMap;return Nt={scopeMethods:c=>{P.has(c)||P.set(c,{sym:new Map,ref:new Map,format:new Map,pattern:new Map});const m=P.get(c),y=g=>{m.sym.get(g)||m.sym.set(g,0);const e=m.sym.get(g);return m.sym.set(g,e+1),s(`${g}${e}`)},w=g=>{if(m.pattern.has(g))return m.pattern.get(g);const e=y("pattern");return c[e]=new RegExp(g,"u"),m.pattern.set(g,e),e};return m.loop||(m.loop="ijklmnopqrstuvxyz".split("")),{gensym:y,genpattern:w,genloop:()=>{const g=m.loop.shift();return m.loop.push(`${g}${g[0]}`),s(g)},getref:g=>m.ref.get(g),genref:g=>{const e=y("ref");return m.ref.set(g,e),e},genformat:g=>{let e=m.format.get(g);return e||(e=y("format"),c[e]=g,m.format.set(g,e)),e}}}},Nt}var Pt,Rr;function Jt(){if(Rr)return Pt;Rr=1;const s=e=>/[\uD800-\uDFFF]/.test(e)?[...e].length:e.length,P=(e,f,i,a)=>{if(e%f===0)return!0;let l=e*i;if((l===1/0||l===-1/0)&&(l=e),l%a===0)return!0;const b=Math.floor(l+.5);return b/i===e&&b%a===0},E=(e,f)=>{if(e===f)return!0;if(!e||!f||typeof e!=typeof f||e!==f&&typeof e!="object")return!1;const i=Object.getPrototypeOf(e);if(i!==Object.getPrototypeOf(f))return!1;if(i===Array.prototype)return!Array.isArray(e)||!Array.isArray(f)||e.length!==f.length?!1:e.every((a,l)=>E(a,f[l]));if(i===Object.prototype){const[a,l]=[Object.keys(e),Object.keys(f)];return a.length!==l.length?!1:new Set([...a,...l]).size===a.length&&a.every(k=>E(e[k],f[k]))}return!1},c=e=>{if(e.length<2)return!0;if(e.length===2)return!E(e[0],e[1]);const f=[],i=e.length>20?new Set:null;let a=0,l=0;for(const b of e){if(typeof b=="object")f.push(b);else if(i){if(i.add(b),i.size!==++a)return!1}else if(e.indexOf(b,l+1)!==-1)return!1;l++}for(let b=1;b<f.length;b++)for(let k=0;k<b;k++)if(E(f[b],f[k]))return!1;return!0},m=e=>{if(typeof Buffer<"u")return Buffer.from(e,"base64").toString("utf-8");const f=atob(e);return new TextDecoder("utf-8").decode(new Uint8Array(f.length).map((i,a)=>f.charCodeAt(a)))},y=Function.prototype.call.bind(Object.prototype.hasOwnProperty);y[Symbol.for("toJayString")]="Function.prototype.call.bind(Object.prototype.hasOwnProperty)";const w=e=>/~\//.test(e)?`${e}`.replace(/~/g,"~0").replace(/\//g,"~1"):e;return Pt={stringLength:s,isMultipleOf:P,deepEqual:E,unique:c,deBase64:m,hasOwn:y,...{toPointer:e=>e.length===0?"#":`#/${e.map(w).join("/")}`,pointerPart:w,errorMerge:({keywordLocation:e,instanceLocation:f},i,a)=>({keywordLocation:`${i}${e.slice(1)}`,instanceLocation:`${a}${f.slice(1)}`}),propertyIn:(e,[f,i])=>f.includes(!0)||f.some(a=>a===e)||i.some(a=>new RegExp(a,"u").test(e)),dynamicResolve:(e,f)=>(e.filter(i=>i[f])[0]||{})[f]}},Pt}var Dt,Ar;function Fr(){if(Ar)return Dt;Ar=1;const{format:s,safe:P}=wt(),{scopeMethods:E}=Ur(),c=Jt(),m=new Map(Object.entries({null:e=>s("%s === null",e),boolean:e=>s('typeof %s === "boolean"',e),array:e=>s("Array.isArray(%s)",e),object:e=>s('typeof %s === "object" && %s && !Array.isArray(%s)',e,e,e),number:e=>s('typeof %s === "number"',e),integer:e=>s("Number.isInteger(%s)",e),string:e=>s('typeof %s === "string"',e)})),y=({name:e,parent:f,keyval:i,keyname:a})=>{if(e){if(f||i||a)throw new Error("name can be used only stand-alone");return e}if(!f)throw new Error("Can not use property of undefined parent!");const l=y(f);if(i!==void 0){if(a)throw new Error("Can not use key value and name together");if(!["string","number"].includes(typeof i))throw new Error("Invalid property path");return/^[a-z][a-z0-9_]*$/i.test(i)?s("%s.%s",l,P(i)):s("%s[%j]",l,i)}else if(a)return s("%s[%s]",l,a);throw new Error("Unreachable")},w=new Set([].concat(...[Object,Array,String,Number,Boolean].map(e=>Object.getOwnPropertyNames(e.prototype)))),M=(e,f,i,{unmodifiedPrototypes:a,isJSON:l},b)=>{const{gensym:k,genpattern:D,genloop:F}=E(f,i);return{present:j=>{const z=y(j),{parent:R,keyval:T,keyname:Q,inKeys:B,checked:te}=j;if(te||B&&l)throw new Error("Unreachable: useless check for undefined");if(B)return s("%s !== undefined",z);if(R&&Q){f.hasOwn=c.hasOwn;const re=y(R);return l?s("%s !== undefined && hasOwn(%s, %s)",z,re,Q):s("%s in %s && hasOwn(%s, %s)",Q,re,re,Q)}else if(R&&T!==void 0){if(a&&l&&!w.has(`${T}`))return s("%s !== undefined",z);f.hasOwn=c.hasOwn;const re=y(R);return l?s("%s !== undefined && hasOwn(%s, %j)",z,re,T):s("%j in %s && hasOwn(%s, %j)",T,re,re,T)}throw new Error("Unreachable: present() check without parent")},forObjectKeys:(j,z)=>{const R=k("key");e.block(s("for (const %s of Object.keys(%s))",R,y(j)),()=>{z(i(j,R,!0),R)})},forArray:(j,z,R)=>{const T=F(),Q=y(j);e.block(s("for (let %s = %s; %s < %s.length; %s++)",T,z,T,Q,T),()=>{R(i(j,T,a,!0),T)})},patternTest:(j,z)=>{const R=j.replace(/[.^$|*+?(){}[\]\\]/gu,"");if(j===`^${R}$`)return s("(%s === %j)",z,j.slice(1,-1));if(b.has(j))return s("true");if([R,`${R}+`,`${R}.*`,`.*${R}.*`].includes(j))return s("%s.includes(%j)",z,R);if([`^${R}`,`^${R}+`,`^${R}.*`].includes(j))return s("%s.startsWith(%j)",z,R);if([`${R}$`,`.*${R}$`].includes(j))return s("%s.endsWith(%j)",z,R);const T=[...R].slice(0,-1).join("");return[`${R}*`,`${R}?`].includes(j)?T.length===0?s("true"):s("%s.includes(%j)",z,T):[`^${R}*`,`^${R}?`].includes(j)?T.length===0?s("true"):s("%s.startsWith(%j)",z,T):s("%s.test(%s)",D(j),z)},compare:(j,z)=>{if(!z||typeof z!="object")return s("%s === %j",j,z);let R;const T=Q=>Q.length<=3&&Q.every(B=>!B||typeof B!="object");if(Array.isArray(z)){if(R=m.get("array")(j),T(z)){let Q=s("%s.length === %d",j,z.length);for(let B=0;B<z.length;B++)Q=s("%s && %s[%d] === %j",Q,j,B,z[B]);return s("%s && %s",R,Q)}}else{R=m.get("object")(j);const[Q,B]=[Object.keys(z),Object.values(z)];if(T(B)){let te=s("Object.keys(%s).length === %d",j,Q.length);Q.length>0&&(f.hasOwn=c.hasOwn);for(const re of Q)te=s("%s && hasOwn(%s, %j)",te,j,re);for(const re of Q)te=s("%s && %s[%j] === %j",te,j,re,z[re]);return s("%s && %s",R,te)}}return f.deepEqual=c.deepEqual,s("%s && deepEqual(%s, %j)",R,j,z)},propvar:i}},G=/^\([^)]*\) *=>/,ne=/^[^=]*=>/,H=Symbol.for("toJayString");function g(e){if(typeof e=="function"){if(e[H])return e[H];if(Object.getPrototypeOf(e)!==Function.prototype)throw new Error("Can not stringify: a function with unexpected prototype");const f=`${e}`;if(e.prototype){if(!/^function[ (]/.test(f))throw new Error("Unexpected function");return f}if(G.test(f)||ne.test(f))return f;throw new Error("Can not stringify: only either normal or arrow functions are supported")}else if(typeof e=="object"){const f=Object.getPrototypeOf(e);if(e instanceof RegExp&&f===RegExp.prototype)return s("%r",e);throw new Error("Can not stringify: an object with unexpected prototype")}throw new Error(`Can not stringify: unknown type ${typeof e}`)}return Dt={types:m,buildName:y,jsHelpers:M,jaystring:g},Dt}var _t,zr;function Tr(){if(zr)return _t;zr=1;const{format:s,safe:P,safenot:E}=wt(),{jaystring:c}=Fr(),m=/[{[]/,y=/[}\]]/;return _t=()=>{const w=[];let M=0;const G=g=>{y.test(g.trim()[0])&&M--,w.push({indent:M,code:g}),m.test(g[g.length-1])&&M++},ne=()=>{if(M!==0)throw new Error("Unexpected indent at build()");const g=w.map(e=>s("%w%s",e.indent*2,e.code)).join(`
`);return/^[a-z][a-z0-9]*$/i.test(g)?`return ${g}`:`return (${g})`},H=g=>{const e=Object.entries(g);for(const[f,i]of e){if(!/^[a-z][a-z0-9]*$/i.test(f))throw new Error("Unexpected scope key!");if(!(typeof i=="function"||i instanceof RegExp))throw new Error("Unexpected scope value!")}return e};return{optimizedOut:!1,size:()=>w.length,write(g,...e){if(typeof g!="string")throw new Error("Format must be a string!");if(g.includes(`
`))throw new Error("Only single lines are supported");return G(s(g,...e)),!0},block(g,e,f=!1){const i=M;this.write("%s {",g);const a=w.length;if(e(),a===w.length)return w.pop(),M=i,!1;if(a===w.length-1&&!f){const{code:l}=w[w.length-1];if(!/^(if|for) /.test(l))return w.length-=2,M=i,this.write("%s %s",g,l)}return this.write("}")},if(g,e,f){`${g}`=="false"?(f&&f(),e&&(this.optimizedOut=!0)):`${g}`=="true"?(e&&e(),f&&(this.optimizedOut=!0)):e&&this.block(s("if (%s)",g),e,!!f)?f&&this.block(s("else"),f):f&&this.if(E(g),f)},makeModule(g={}){return`(function() {
'use strict'
${H(g).map(([f,i])=>`const ${P(f)} = ${c(i)};`).join(`
`)}
${ne()}})()`},makeFunction(g={}){const e=H(g),f=e.map(a=>a[0]),i=e.map(a=>a[1]);return Function(...f,`'use strict'
${ne()}`)(...i)}}},_t}var Ct,qr;function Lr(){if(qr)return Ct;qr=1;const s=["$schema","$vocabulary","id","$id","$anchor","$ref","definitions","$defs","$recursiveRef","$recursiveAnchor","$dynamicAnchor","$dynamicRef","type","required","default","enum","const","not","allOf","anyOf","oneOf","if","then","else","maximum","minimum","exclusiveMaximum","exclusiveMinimum","multipleOf","divisibleBy","items","maxItems","minItems","additionalItems","prefixItems","contains","minContains","maxContains","uniqueItems","maxLength","minLength","format","pattern","contentEncoding","contentMediaType","contentSchema","properties","maxProperties","minProperties","additionalProperties","patternProperties","propertyNames","dependencies","dependentRequired","dependentSchemas","propertyDependencies","unevaluatedProperties","unevaluatedItems","title","description","deprecated","readOnly","writeOnly","examples","$comment","example","discriminator","removeAdditional"],E=["draft/next","draft/2020-12","draft/2019-09","draft-07","draft-06","draft-04","draft-03"].map(w=>`https://json-schema.org/${w}/schema`),c=["core","applicator","validation","meta-data","format","content"],m=["core","applicator","unevaluated","validation","meta-data","format-annotation","format-assertion","content"],y=[...c.map(w=>`https://json-schema.org/draft/2019-09/vocab/${w}`),...m.map(w=>`https://json-schema.org/draft/2020-12/vocab/${w}`)];return Ct={knownKeywords:s,schemaVersions:E,knownVocabularies:y},Ct}var Ut,Mr;function Vr(){if(Mr)return Ut;Mr=1;const{knownKeywords:s}=Lr();function P(l,b,k,D="keys"){if(!l.has(b))return l.set(b,k);if(l.get(b)!==k)throw new Error(`Conflicting duplicate ${D}: ${b}`)}function E(l){return l.includes("~")?l.replace(/~[01]/g,b=>{switch(b){case"~1":return"/";case"~0":return"~"}throw new Error("Unreachable")}):l}function c(l,b,k){if(typeof l!="object")throw new Error("Invalid input object");if(typeof b!="string")throw new Error("Invalid JSON pointer");const D=b.split("/");if(!["","#"].includes(D.shift()))throw new Error("Invalid JSON pointer");if(D.length===0)return l;let F=l;for(const Y of D){if(typeof Y!="string")throw new Error("Invalid JSON pointer");k&&k.push(F);const x=E(Y);if(typeof F!="object"||!Object.prototype.hasOwnProperty.call(F,x))return;F=F[x]}return F}const m=/^https?:\/\//;function y(l,b){if(typeof l!="string"||typeof b!="string")throw new Error("Unexpected path!");if(b.length===0)return l;const k=l.replace(/#.*/,"");return b.startsWith("#")?`${k}${b}`:!k.includes("/")||m.test(b)?b:m.test(k)?`${new URL(b,k)}`:b.startsWith("/")?b:[...k.split("/").slice(0,-1),b].join("/")}function w(l){return l.map(k=>k&&(k.$id||k.id)||"").filter(k=>k&&typeof k=="string").reduce(y,"")}const M=["properties","patternProperties","$defs","definitions"],G=["const","enum","examples","example","comment"],ne=Symbol("skip");function H(l,b){const k=(D,F=!1)=>{if(!D||typeof D!="object")return;const Y=b(D);if(Y!==void 0)return Y===ne?void 0:Y;for(const x of Object.keys(D)){if(!F&&!Array.isArray(D)&&!s.includes(x)||!F&&G.includes(x))continue;const ie=k(D[x],!F&&M.includes(x));if(ie!==void 0)return ie}};return k(l)}function g(l,b,k,D=""){const F=y(D,k),Y=[],[x,ie=""]=F.split("#"),J=decodeURI(ie),we=(j,z,R=!1,T=!1)=>{if(!j||typeof j!="object")return;const Q=j.$id||j.id;let B=z;if(Q&&typeof Q=="string"){if(B=y(B,Q),B===F||B===x&&J==="")Y.push([j,l,z]);else if(B===x&&J[0]==="/"){const re=[],ot=c(j,J,re);ot!==void 0&&Y.push([ot,l,y(z,w(re))])}}const te=T?j.$dynamicAnchor:j.$anchor;if(te&&typeof te=="string"){if(te.includes("#"))throw new Error("$anchor can't include '#'");if(te.startsWith("/"))throw new Error("$anchor can't start with '/'");B=y(B,`#${te}`),B===F&&Y.push([j,l,z])}for(const re of Object.keys(j))!R&&!Array.isArray(j)&&!s.includes(re)||!R&&G.includes(re)||we(j[re],B,!R&&M.includes(re));!T&&j.$dynamicAnchor&&we(j,z,R,!0)};if(we(l,x),x===D.replace(/#$/,"")&&(J[0]==="/"||J==="")){const j=[],z=c(l,J,j);z!==void 0&&Y.push([z,l,w(j)])}if(b.has(x)&&b.get(x)!==l){const j=g(b.get(x),b,`#${ie}`,x);Y.push(...j.map(([z,R,T])=>[z,R,y(x,T)]))}return b.has(F)&&Y.push([b.get(F),b.get(F),F]),Y}function e(l){const b=new Map;return H(l,k=>{if(k!==l&&(k.$id||k.id))return ne;const D=k.$dynamicAnchor;if(D&&typeof D=="string"){if(D.includes("#"))throw new Error("$dynamicAnchor can't include '#'");if(!/^[a-zA-Z0-9_-]+$/.test(D))throw new Error(`Unsupported $dynamicAnchor: ${D}`);P(b,D,k,"$dynamicAnchor")}}),b}const f=(l,b)=>H(l,k=>Object.keys(k).some(D=>b.includes(D))||void 0)||!1,i=(l,b,k=!1)=>{if(!Array.isArray(b))throw new Error("Expected an array of schemas");for(const D of b)H(D,F=>{const Y=F.$id||F.id,x=Y&&typeof Y=="string"?Y.replace(/#$/,""):null;if(x&&x.includes("://")&&!x.includes("#"))P(l,x,F,"schema $id in 'schemas'");else if(F===D&&!k)throw new Error("Schema with missing or invalid $id in 'schemas'")});return l},a=(l,b)=>{if(b)return i(a(l),b,!0);if(l)switch(Object.getPrototypeOf(l)){case Object.prototype:return new Map(Object.entries(l));case Map.prototype:return new Map(l);case Array.prototype:return i(new Map,l)}throw new Error("Unexpected value for 'schemas' option")};return Ut={get:c,joinPath:y,resolveReference:g,getDynamicAnchors:e,hasKeywords:f,buildSchemas:a},Ut}var Ft,Nr;function Yn(){if(Nr)return Ft;Nr=1;const s={email:c=>{if(c.length>318)return!1;if(/^[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,20}(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,21}){0,2}@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,60}[a-z0-9])?){0,3}$/i.test(c))return!0;if(!c.includes("@")||/(^\.|^"|\.@|\.\.)/.test(c))return!1;const[y,w,...M]=c.split("@");return!y||!w||M.length!==0||y.length>64||w.length>253||!/^[a-z0-9.-]+$/i.test(w)||!/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(y)?!1:w.split(".").every(G=>/^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(G))},hostname:c=>c.length>(c.endsWith(".")?254:253)?!1:/^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*\.?$/i.test(c),date:c=>{if(c.length!==10)return!1;if(c[5]==="0"&&c[6]==="2"){if(/^\d\d\d\d-02-(?:[012][1-8]|[12]0|[01]9)$/.test(c))return!0;const m=c.match(/^(\d\d\d\d)-02-29$/);if(!m)return!1;const y=m[1]|0;return y%16===0||y%4===0&&y%25!==0}return c.endsWith("31")?/^\d\d\d\d-(?:0[13578]|1[02])-31$/.test(c):/^\d\d\d\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)$/.test(c)},time:c=>{if(c.length>27||!/^(?:2[0-3]|[0-1]\d):[0-5]\d:(?:[0-5]\d|60)(?:\.\d+)?(?:z|[+-](?:2[0-3]|[0-1]\d)(?::?[0-5]\d)?)?$/i.test(c))return!1;if(!/:60/.test(c))return!0;const y=c.match(/([0-9.]+|[^0-9.])/g);let w=Number(y[0])*60+Number(y[2]);return y[5]==="+"?w+=24*60-Number(y[6]||0)*60-Number(y[8]||0):y[5]==="-"&&(w+=Number(y[6]||0)*60+Number(y[8]||0)),w%(24*60)===23*60+59},"date-time":c=>{if(c.length>38)return!1;const m=/^\d\d\d\d-(?:0[1-9]|1[0-2])-(?:[0-2]\d|3[01])[t\s](?:2[0-3]|[0-1]\d):[0-5]\d:(?:[0-5]\d|60)(?:\.\d+)?(?:z|[+-](?:2[0-3]|[0-1]\d)(?::?[0-5]\d)?)$/i,y=c[5]==="0"&&c[6]==="2";if(y&&c[8]==="3"||!m.test(c))return!1;if(c[17]==="6"){const w=c.slice(11).match(/([0-9.]+|[^0-9.])/g);let M=Number(w[0])*60+Number(w[2]);if(w[5]==="+"?M+=24*60-Number(w[6]||0)*60-Number(w[8]||0):w[5]==="-"&&(M+=Number(w[6]||0)*60+Number(w[8]||0)),M%(24*60)!==23*60+59)return!1}if(y){if(/^\d\d\d\d-02-(?:[012][1-8]|[12]0|[01]9)/.test(c))return!0;const w=c.match(/^(\d\d\d\d)-02-29/);if(!w)return!1;const M=w[1]|0;return M%16===0||M%4===0&&M%25!==0}return c[8]==="3"&&c[9]==="1"?/^\d\d\d\d-(?:0[13578]|1[02])-31/.test(c):/^\d\d\d\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)/.test(c)},ipv4:c=>c.length<=15&&/^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)$/.test(c),ipv6:c=>{if(c.length>45||c.length<2)return!1;let m=0,y=0,w=0,M=!1,G=!1,ne=0,H=!0;for(let e=0;e<c.length;e++){const f=c.charCodeAt(e);if(e===1&&ne===58&&f!==58)return!1;if(f>=48&&f<=57){if(++w>4)return!1}else if(f===46){if(m>6||y>=3||w===0||G)return!1;y++,w=0}else if(f===58){if(y>0||m>=7)return!1;if(ne===58){if(M)return!1;M=!0}else e===0&&(H=!1);m++,w=0,G=!1}else if(f>=97&&f<=102||f>=65&&f<=70){if(y>0||++w>4)return!1;G=!0}else return!1;ne=f}if(m<2||y>0&&(y!==3||w===0))return!1;if(M&&c.length===2)return!0;if(y>0&&!/(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}$/.test(c))return!1;const g=y>0?6:7;return M?(H||w>0)&&m<g:m===g&&H&&w>0},uri:/^[a-z][a-z0-9+\-.]*:(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/?(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,"uri-reference":/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/?(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)?(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,"uri-template":/^(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2}|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,"json-pointer":/^(?:|\/(?:[^~]|~0|~1)*)$/,"relative-json-pointer":/^(?:0|[1-9][0-9]*)(?:|#|\/(?:[^~]|~0|~1)*)$/,uuid:/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,duration:c=>c.length>1&&c.length<80&&(/^P\d+([.,]\d+)?W$/.test(c)||/^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(c)&&/^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(c))},P={alpha:/^[a-zA-Z]+$/,alphanumeric:/^[a-zA-Z0-9]+$/,"hex-digits":/^[0-9a-f]+$/i,"hex-digits-prefixed":/^0x[0-9a-f]+$/i,"hex-bytes":/^([0-9a-f][0-9a-f])+$/i,"hex-bytes-prefixed":/^0x([0-9a-f][0-9a-f])+$/i,base64:c=>c.length%4===0&&/^[a-z0-9+/]*={0,3}$/i.test(c),"json-pointer-uri-fragment":/^#(|\/(\/|[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)$/i,"host-name":s.hostname,"ip-address":s.ipv4,color:/^(#[0-9A-Fa-f]{3,6}|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|rgb\(\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*,\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*,\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*\)|rgb\(\s*(\d?\d%|100%)\s*,\s*(\d?\d%|100%)\s*,\s*(\d?\d%|100%)\s*\))$/};return Ft={core:s,extra:P,weak:{regex:c=>{if(c.length>1e5||/[^\\]\\Z/.test(c))return!1;try{return new RegExp(c,"u"),!0}catch{return!1}}}},Ft}var Tt,Pr;function Xn(){if(Pr)return Tt;Pr=1;const s=(i,a)=>[...new Set([...i,...a])].sort(),P=(i,a)=>i.filter(l=>a.includes(l)),E=i=>(...a)=>i(...a.map(y)),c=i=>(...a)=>y(i(...a.map(y))),m=(i,a)=>i&&!i.includes(a),y=({type:i=null,dyn:a={},...l})=>({type:i&&[...i].sort(),items:m(i,"array")?1/0:l.items||0,properties:m(i,"object")?[!0]:[...l.properties||[]].sort(),patterns:m(i,"object")?[]:[...l.patterns||[]].sort(),required:m(i,"object")?[]:[...l.required||[]].sort(),fullstring:m(i,"string")||l.fullstring||!1,dyn:{item:m(i,"array")?!1:a.item||!1,items:m(i,"array")?0:Math.max(l.items||0,a.items||0),properties:m(i,"object")?[]:s(l.properties||[],a.properties||[]),patterns:m(i,"object")?[]:s(l.patterns||[],a.patterns||[])},unknown:l.unknown&&!(m(i,"object")&&m(i,"array"))||!1}),w=()=>y({}),M=c((i,a)=>({type:i.type&&a.type?P(i.type,a.type):i.type||a.type||null,items:Math.max(i.items,a.items),properties:s(i.properties,a.properties),patterns:s(i.patterns,a.patterns),required:s(i.required,a.required),fullstring:i.fullstring||a.fullstring,dyn:{item:i.dyn.item||a.dyn.item,items:Math.max(i.dyn.items,a.dyn.items),properties:s(i.dyn.properties,a.dyn.properties),patterns:s(i.dyn.patterns,a.dyn.patterns)},unknown:i.unknown||a.unknown})),G=(i,a)=>a!==!0&&new RegExp(i,"u").test(a),ne=({properties:i,patterns:a},{properties:l,patterns:b})=>{const k=i.filter(x=>l.includes(x)||l.includes(!0)||b.some(ie=>G(ie,x))),D=l.filter(x=>i.includes(x)||i.includes(!0)||a.some(ie=>G(ie,x))),F=a.filter(x=>b.includes(x)||l.includes(!0)),Y=b.filter(x=>a.includes(x)||i.includes(!0));return{properties:s(k,D),patterns:s(F,Y)}},H=({properties:i,patterns:a},{properties:l,patterns:b})=>l.every(k=>i.includes(k)||i.includes(!0)||a.some(D=>G(D,k)))&&b.every(k=>a.includes(k)||i.includes(!0)),g=c((i,a)=>({type:i.type&&a.type?s(i.type,a.type):null,items:Math.min(i.items,a.items),...ne(i,a),required:m(i.type,"object")&&a.required||m(a.type,"object")&&i.required||P(i.required,a.required),fullstring:i.fullstring&&a.fullstring,dyn:{item:i.dyn.item||a.dyn.item,items:Math.max(i.dyn.items,a.dyn.items),properties:s(i.dyn.properties,a.dyn.properties),patterns:s(i.dyn.patterns,a.dyn.patterns)},unknown:i.unknown||a.unknown})),e=(i,a)=>Object.assign(i,M(i,a)),f=E(({unknown:i,items:a,dyn:l,...b})=>({items:a!==1/0&&(i||l.items>a||l.item),properties:!b.properties.includes(!0)&&(i||!H(b,l))}));return Tt={initTracing:w,andDelta:M,orDelta:g,applyDelta:e,isDynamic:f,inProperties:H},Tt}var Lt,Dr;function Qn(){if(Dr)return Lt;Dr=1;const{format:s,safe:P,safeand:E,safenot:c,safenotor:m}=wt(),y=Tr(),{resolveReference:w,joinPath:M,getDynamicAnchors:G,hasKeywords:ne}=Vr(),H=Yn(),{toPointer:g,...e}=Jt(),{scopeMethods:f}=Ur(),{buildName:i,types:a,jsHelpers:l}=Fr(),{knownKeywords:b,schemaVersions:k,knownVocabularies:D}=Lr(),{initTracing:F,andDelta:Y,orDelta:x,applyDelta:ie,isDynamic:J,inProperties:we}=Xn(),j=new Set(["^[\\s\\S]*$","^[\\S\\s]*$","^[^]*$","",".*","^","$"]),z=["null","boolean","number","integer","string"],R=new Map(Object.entries({boolean:$=>typeof $=="boolean",array:$=>Array.isArray($)&&Object.getPrototypeOf($)===Array.prototype,object:$=>$&&Object.getPrototypeOf($)===Object.prototype,finite:$=>Number.isFinite($),natural:$=>Number.isInteger($)&&$>=0,string:$=>typeof $=="string",jsonval:$=>e.deepEqual($,JSON.parse(JSON.stringify($)))})),T=R.get("object"),Q=$=>T($)||typeof $=="boolean",B=$=>e.deepEqual($,{type:[]}),te=($,L)=>k.indexOf($)>k.indexOf(`https://json-schema.org/${L}/schema`),re=($,L)=>{const A=`${$}`.replace(/^http:\/\//,"https://").replace(/#$/,"");return k.includes(A)?te(A,L):!0},ot=($,L,A=!1,V=!1)=>Object.freeze({parent:$,keyname:L,inKeys:A,number:V}),Wr=($,L,A=!1)=>Object.freeze({parent:$,keyval:L,checked:A}),bt=Symbol("evaluatedStatic"),Ee=Symbol("optDynamic"),Ue=Symbol("optDynAnchors"),Qe=Symbol("optRecAnchors"),Jr=$=>{if(typeof $=="boolean")return $;if(T($)&&Object.keys($).length===0)return!0},Se=new Set,Be=new Map,Kr=($,L,A,V)=>{if(L){const ae=L.replace(/^http:\/\//,"https://").replace(/#$/,"");A(k.includes(ae),"Unexpected schema version:",ae),Be.set($,{exclusiveRefs:te(ae,"draft/2019-09"),contentValidation:te(ae,"draft/2019-09"),dependentUnsupported:te(ae,"draft/2019-09"),newItemsSyntax:!te(ae,"draft/2020-12"),containsEvaluates:!te(ae,"draft/2020-12"),objectContains:!te(ae,"draft/next"),bookending:te(ae,"draft/next")})}else A(!V,"[requireSchema] $schema is required"),Be.set($,{})},Kt=($,L,A,V,ae="")=>{const{mode:je="default",useDefaults:Ht=!1,removeAdditional:Fe=!1,includeErrors:ye=!1,allErrors:de=!1,contentValidation:Zt,dryRun:cs,lint:et=!1,allowUnusedKeywords:Ne=A.mode==="lax"||A.mode==="spec",allowUnreachable:Hr=A.mode==="lax"||A.mode==="spec",requireSchema:vt=A.mode==="strong",requireValidation:ct=A.mode==="strong",requireStringValidation:ft=A.mode==="strong",forbidNoopValues:Zr=A.mode==="strong",complexityChecks:Gt=A.mode==="strong",unmodifiedPrototypes:Gr=!1,isJSON:Yt=!1,$schemaDefault:Xt=null,formatAssertion:Qt=A.mode!=="spec"||re(L.$schema,"draft/2019-09"),formats:Bt={},weakFormats:er=A.mode!=="strong",extraFormats:Yr=!1,schemas:Te,...tr}=A,Xr={...H.core,...er?H.weak:{},...Yr?H.extra:{},...Bt};if(Object.keys(tr).length!==0)throw new Error(`Unknown options: ${Object.keys(tr).join(", ")}`);if(!["strong","lax","default","spec"].includes(je))throw new Error(`Invalid mode: ${je}`);if(!ye&&de)throw new Error("allErrors requires includeErrors to be enabled");if(vt&&Xt)throw new Error("requireSchema forbids $schemaDefault");if(je==="strong"){const le={...{requireValidation:ct,requireStringValidation:ft},formatAssertion:Qt,complexityChecks:Gt,requireSchema:vt},S={weakFormats:er,allowUnusedKeywords:Ne};for(const[u,oe]of Object.entries(le))if(!oe)throw new Error(`Strong mode demands ${u}`);for(const[u,oe]of Object.entries(S))if(oe)throw new Error(`Strong mode forbids ${u}`)}const{gensym:he,getref:Qr,genref:Br,genformat:rr}=f(V),en=fe=>{const le=[];let S=fe;for(;S;)S.name||le.unshift(S),S=S.parent||S.errorParent;if(le.every(ge=>ge.keyval!==void 0))return s("%j",g(le.map(ge=>ge.keyval)));const u=["#"],oe=()=>{const ge=u.map(e.pointerPart).join("/");return u.length=0,ge};let be=null;for(const{keyname:ge,keyval:pt,number:De}of le)if(ge){De||(V.pointerPart=e.pointerPart);const Ve=De?ge:s("pointerPart(%s)",ge),C=`${oe()}/`;be=be?s("%s+%j+%s",be,C,Ve):s("%j+%s",C,Ve)}else pt&&u.push(pt);return u.length>0?s("%s+%j",be,`/${oe()}`):be},Oe=Br($);let lt=null;const nr=(...fe)=>{const le=lt(...fe);return nr.errors=lt.errors,le};V[Oe]=nr;const tn=ne($,["$ref","$recursiveRef","$dynamicRef"]),$t=A[Ue]&&tn&&ne($,["$dynamicAnchor"]),rn=()=>A[Ue]?s($t?", dynAnchors = []":", dynAnchors"):s(""),nn=A[Qe]?s(", recursive"):s(""),p=y();p.write("function validate(data%s%s) {",nn,rn()),ye&&p.write("validate.errors = null"),de&&p.write("let errorCount = 0"),A[Ee]&&p.write("validate.evaluatedDynamic = null");let sr=A[Ue]?s(", dynAnchors"):s("");$t&&(p.write("const dynLocal = [{}]"),sr=s(", [...dynAnchors, dynLocal[0] || []]"));const sn=l(p,V,ot,{unmodifiedPrototypes:Gr,isJSON:Yt},j),{present:ke,forObjectKeys:ut,forArray:jt,patternTest:on,compare:Ot}=sn,Pe=[],ce=()=>Be.get(L),Le=ae?[ae]:[],kt=(fe,le,S,u,oe,be={},{constProp:ge}={})=>{const pt=le.length>0&&le[le.length-1].prop===S,De=()=>le.filter(t=>t.prop===S),Ve=!S.parent||S.checked||S.inKeys&&Yt||De().length>0,C=i(S),_e=(...t)=>Wr(S,...t),Ie=({path:t=[],prop:n=S,source:o,suberr:d})=>{const r=g([...oe,...t]),h=ye?en(n):null;if(ye===!0&&fe&&o){V.errorMerge=e.errorMerge;const v=[o,r,h];de?(p.write("if (validate.errors === null) validate.errors = []"),p.write("validate.errors.push(...%s.map(e => errorMerge(e, %j, %s)))",...v)):p.write("validate.errors = [errorMerge(%s[0], %j, %s)]",...v)}else if(ye===!0&&fe){const v=s("{ keywordLocation: %j, instanceLocation: %s }",r,h);de?(p.write("if (%s === null) %s = []",fe,fe),p.write("%s.push(%s)",fe,v)):p.write("%s = [%s]",fe,v)}d&&gr(d),de?p.write("errorCount++"):p.write("return false")},pe=(t,n)=>p.if(t,()=>Ie(n));et&&!V.lintErrors&&(V.lintErrors=[]);const xe=(t,n)=>{const o=n!==void 0?` ${JSON.stringify(n)}`:"",d=M(ae,g(oe)),r=`${t}${o} at ${d}`;if(et)return V.lintErrors.push({message:r,keywordLocation:d,schema:$});throw new Error(r)},Et=(t,n)=>{try{return on(t,n)}catch(o){return xe(o.message),s("false")}},q=(t,...n)=>t||xe(...n),tt=(t,...n)=>q(je==="lax"||je==="spec"||t,...n),Re=(t,n)=>tt(!(u[n]<u[t]),`Invalid ${t} / ${n} combination`),Ae=(t,n="should be specified")=>q(!ct,`[requireValidation] ${t} ${n}`),se=(...t)=>[...oe,...t],We=t=>q(!Fe&&!Ht,`[removeAdditional/useDefaults] uncertain: ${t}`),ir=(t,n)=>q(!Gt,`[complexityChecks] ${t}`,n),or=t=>Kr(L,t||Xt,q,vt),N=F(),W=t=>ie(N,t);if(typeof u=="boolean")return u===!0?(Ae("schema = true","is not allowed"),{stat:N}):(pe(Ve||S.inKeys?!0:ke(S),{}),W({type:[]}),{stat:N});q(T(u),"Schema is not an object");for(const t of Object.keys(u))q(b.includes(t)||Ne,"Keyword not supported:",t);if(Object.keys(u).length===0)return Ae("empty rules node","is not allowed"),{stat:N};const ze=new Set(Object.keys(u)),ar=new Set,qe=(t,...n)=>{q(ar.has(t)||ze.has(t),"Unexpected double consumption:",t),q(e.hasOwn(u,t),"Is not an own property:",t),q(n.every(o=>R.has(o)),"Invalid type used in consume"),q(n.some(o=>R.get(o)(u[t])),"Unexpected type for",t),ze.delete(t)},cr=(t,...n)=>(u[t]!==void 0&&qe(t,...n),u[t]),O=(t,n,o,d={})=>{if(u[t]===void 0)return!1;if(qe(t,...n),o!==null)try{const r=o(u[t]);r!==null&&pe(r,{path:[t],...d})}catch(r){if(et&&!r.message.startsWith("[opt] "))xe(r.message);else throw r}return!0};if(u===L?(or(cr("$schema","string")),O("$vocabulary",["object"],t=>{for(const[n,o]of Object.entries(t))o!==!1&&q(o===!0&&D.includes(n),"Unknown vocabulary:",n);return null})):ce()||or(L.$schema),ce().objectContains)for(const t of["contains","minContains","maxContains"])ar.add(t);O("examples",["array"],null),O("example",["jsonval"],null);for(const t of["title","description","$comment"])O(t,["string"],null);for(const t of["deprecated","readOnly","writeOnly"])O(t,["boolean"],null);O("$defs",["object"],null)||O("definitions",["object"],null);const rt=(t,n,o)=>t===$?P("validate"):Qr(t)||Kt(t,n,A,V,o),Me=()=>Le.length>0?Le[Le.length-1]:"",an=Le.length,fr=t=>(Le.push(M(Me(),t)),null);(!ce().exclusiveRefs||!u.$ref)&&(O("$id",["string"],fr)||O("id",["string"],fr),O("$anchor",["string"],null),O("$dynamicAnchor",["string"],null),(u.$recursiveAnchor||!Zr)&&O("$recursiveAnchor",["boolean"],t=>(t&&Pe.push([u,L,Me()]),null)));const lr=$t&&(u===$||u.id||u.$id);if(lr){const t=G(u);u!==$&&p.write("dynLocal.unshift({})");for(const[n,o]of t){const d=w(L,Te,`#${n}`,Me()),[r,h,v]=d[0]||[];q(r===o,`Unexpected $dynamicAnchor resolution: ${n}`);const I=rt(r,h,v);p.write("dynLocal[0][%j] = %s",`#${n}`,I)}}const St=t=>A[Ee]&&(u[t]||u[t]===!1||u===$),me=Object.freeze({item:St("unevaluatedItems")?he("evaluatedItem"):null,items:St("unevaluatedItems")?he("evaluatedItems"):null,props:St("unevaluatedProperties")?he("evaluatedProps"):null}),X=Object.freeze({item:me.item||be.item,items:me.items||be.items,props:me.props||be.props}),ur=()=>(!X.items||N.items===1/0)&&(!X.props||N.properties.includes(!0)),ve=t=>{if(X.item&&t.item&&N.items!==1/0&&p.write("%s.push(%s)",X.item,t.item),X.items&&t.items>N.items&&p.write("%s.push(%d)",X.items,t.items),X.props&&(t.properties||[]).includes(!0)&&!N.properties.includes(!0))p.write("%s[0].push(true)",X.props);else if(X.props){const n=(r,h)=>we(N,{properties:r,patterns:h}),o=(t.properties||[]).filter(r=>!n([r],[])),d=(t.patterns||[]).filter(r=>!n([],[r]));o.length>0&&p.write("%s[0].push(...%j)",X.props,o),d.length>0&&p.write("%s[1].push(...%j)",X.props,d);for(const r of t.propertiesVars||[])p.write("%s[0].push(%s)",X.props,r)}},dr=(t,n,o,d)=>{J(N).items&&t.item&&n&&p.write("%s.push(...%s)",t.item,n),J(N).items&&t.items&&o&&p.write("%s.push(...%s)",t.items,o),J(N).properties&&t.props&&d&&(p.write("%s[0].push(...%s[0])",t.props,d),p.write("%s[1].push(...%s[1])",t.props,d))},cn=()=>A[Qe]?Pe.length===0?s(", recursive"):s(", recursive || %s",rt(...Pe[0])):s(""),mt=(t,n)=>{const o=V[t]&&V[t][bt]||{unknown:!0};W(o);const d=s("%s(%s%s%s)",t,C,cn(),sr);if(!ye&&ur())return s("!%s",d);const r=he("res"),h=he("err"),v=he("suberr");return ye&&p.write("const %s = validate.errors",h),p.write("const %s = %s",r,d),ye&&p.write("const %s = %s.errors",v,t),ye&&p.write("validate.errors = %s",h),pe(c(r),{...n,source:v}),p.if(r,()=>{const I=J(o).items?s("%s.evaluatedDynamic[0]",t):null,_=J(o).items?s("%s.evaluatedDynamic[1]",t):null,U=J(o).properties?s("%s.evaluatedDynamic[2]",t):null;dr(X,I,_,U)}),null},pr=(t,n)=>t&&t.every(o=>n.includes(o)),mr=(t,n)=>n.some(o=>t===null||t.includes(o)),hr=(...t)=>De().some(n=>pr(n.stat.type,t)),fn=(...t)=>pr(N.type,t)||hr(...t),Je=(...t)=>mr(N.type,t)&&De().every(n=>mr(n.stat.type,t)),It=(t,n=u)=>{q(typeof t=="string","Invalid pattern:",t),(ct||ft)&&q(/^\^.*\$$/.test(t),"Should start with ^ and end with $:",t),/([{+*].*[{+*]|\)[{+*]|^[^^].*[{+*].)/.test(t)&&n.maxLength===void 0&&ir("maxLength should be specified for pattern:",t)},ln=u.pattern&&!j.has(u.pattern),un=u.uniqueItems||ln||u.patternProperties||u.format,ht=de&&un?he("prev"):null,yt=(t,n)=>p.if(t&&ht!==null?s("errorCount === %s",ht):!0,n),yr=()=>[...le,{stat:N,prop:S}],ue=(...t)=>kt(fe,yr(),...t).stat,Ce=(t,...n)=>{if(n[0]===S){const r=Jr(n[1]);if(r===!0)return{sub:s("true"),delta:{}};if(r===!1)return{sub:s("false"),delta:{type:[]}}}const o=he("sub");p.write("const %s = (() => {",o),de&&p.write("let errorCount = 0");const{stat:d}=kt(t,yr(),...n);return de?p.write("return errorCount === 0"):p.write("return true"),p.write("})()"),{sub:o,delta:d}},Rt=()=>{const t=ye&&de?he("suberr"):null;return t&&p.write("let %s = null",t),t},gr=t=>{fe===null||t===null||p.if(t,()=>p.write("%s.push(...%s)",fe,t))},wr=()=>{if(!Fe)return!1;if(Fe===!0)return!0;if(Fe==="keyword")return u.removeAdditional?(qe("removeAdditional","boolean"),!0):!1;throw new Error(`Invalid removeAdditional: ${Fe}`)},gt=(t,n,o)=>{O(t,["object","boolean"],r=>r===!1&&wr()?(p.write("if (%s.length > %s) %s.length = %s",C,n,C,n),null):r===!1&&!o?s("%s.length > %s",C,n):(jt(S,n,(h,v)=>(o&&p.write("if (%s) continue",o(v)),ue(h,r,se(t)))),null))&&W({items:1/0})},At=(t,n)=>{O(t,["object","boolean"],d=>(ut(S,(r,h)=>{p.if(n(h),()=>{d===!1&&wr()?p.write("delete %s[%s]",C,h):ue(r,d,se(t))})}),null))&&W({properties:[!0]})},br=(t,n,o)=>E(...n.map(d=>s("%s !== %j",t,d)),...o.map(d=>c(Et(d,t)))),vr=(t,n)=>{const o=n.map(r=>new RegExp(r,"u")),d=r=>t.includes(r)||o.some(h=>h.test(r));for(const r of N.required)q(d(r),"Unknown required property:",r)},$r=[],dn=()=>{const t=(o,d)=>s("!(%d %c %s)",o,d,C);Number.isFinite(u.exclusiveMinimum)?O("exclusiveMinimum",["finite"],o=>t(o,"<")):(O("minimum",["finite"],o=>t(o,u.exclusiveMinimum?"<":"<=")),O("exclusiveMinimum",["boolean"],null)),Number.isFinite(u.exclusiveMaximum)?(O("exclusiveMaximum",["finite"],o=>t(o,">")),Re("minimum","exclusiveMaximum"),Re("exclusiveMinimum","exclusiveMaximum")):u.maximum!==void 0&&(O("maximum",["finite"],o=>t(o,u.exclusiveMaximum?">":">=")),O("exclusiveMaximum",["boolean"],null),Re("minimum","maximum"),Re("exclusiveMinimum","maximum"));const n=u.multipleOf===void 0?"divisibleBy":"multipleOf";O(n,["finite"],o=>{q(o>0,`Invalid ${n}:`,o);const[d,r]=`${o}`.split("e-"),v=`${d}.`.split(".")[1].length+(r?Number(r):0);if(Number.isInteger(o*2**v))return s("%s %% %d !== 0",C,o);V.isMultipleOf=e.isMultipleOf;const I=[C,o,v,Math.round(o*Math.pow(10,v))];return s("!isMultipleOf(%s, %d, 1e%d, %d)",...I)})},pn=()=>{O("maxLength",["natural"],t=>(V.stringLength=e.stringLength,s("%s.length > %d && stringLength(%s) > %d",C,t,C,t))),O("minLength",["natural"],t=>(V.stringLength=e.stringLength,s("%s.length < %d || stringLength(%s) < %d",C,t,C,t))),Re("minLength","maxLength"),yt(!0,()=>{const t=(r,h,v=Xr)=>{const I=typeof r=="string"&&e.hasOwn(v,r);q(I,"Unrecognized format used:",r);const _=v[r],U=_ instanceof RegExp||typeof _=="function";return q(U,"Invalid format used:",r),Qt?_ instanceof RegExp?(e.hasOwn(Bt,r)&&It(_.source),s("!%s.test(%s)",rr(_),h)):s("!%s(%s)",rr(_),h):null};O("format",["string"],r=>(W({fullstring:!0}),t(r,C))),O("pattern",["string"],r=>(It(r),W({fullstring:!0}),j.has(r)?null:c(Et(r,C)))),q(u.contentSchema!==!1,"contentSchema cannot be set to false");const n=Zt===void 0?ce().contentValidation:Zt,o=u.contentEncoding||u.contentMediaType||u.contentSchema;if(q(!o||n||Ne,'"content*" keywords are disabled by default per spec, enable with { contentValidation = true } option (see doc/Options.md for more info)'),o&&n){const r=he("dec");u.contentMediaType&&p.write("let %s = %s",r,C),u.contentEncoding==="base64"?(pe(t("base64",C,H.extra),{path:["contentEncoding"]}),u.contentMediaType&&(V.deBase64=e.deBase64,p.write("try {"),p.write("%s = deBase64(%s)",r,r)),qe("contentEncoding","string")):q(!u.contentEncoding,"Unknown contentEncoding:",u.contentEncoding);let h=!1;if(u.contentMediaType==="application/json"?(p.write("try {"),p.write("%s = JSON.parse(%s)",r,r),h=!0,qe("contentMediaType","string")):q(!u.contentMediaType,"Unknown contentMediaType:",u.contentMediaType),u.contentSchema){q(h,"contentSchema requires contentMediaType application/json");const v=Object.freeze({name:r,errorParent:S});ue(v,u.contentSchema,se("contentSchema")),qe("contentSchema","object","array"),W({fullstring:!0})}u.contentMediaType&&(p.write("} catch (e) {"),Ie({path:["contentMediaType"]}),p.write("}"),u.contentEncoding&&(p.write("} catch (e) {"),Ie({path:["contentEncoding"]}),p.write("}")))}})},mn=()=>{O("maxItems",["natural"],r=>{const h=ce().newItemsSyntax?"prefixItems":"items";return Array.isArray(u[h])&&u[h].length>r&&xe(`Invalid maxItems: ${r} is less than ${h} array length`),s("%s.length > %d",C,r)}),O("minItems",["natural"],r=>s("%s.length < %d",C,r)),Re("minItems","maxItems");const t=r=>{for(let h=0;h<r.length;h++)ue(_e(h),r[h],se(`${h}`));return W({items:r.length}),null};ce().newItemsSyntax?(O("prefixItems",["array"],t),gt("items",s("%d",(u.prefixItems||[]).length))):Array.isArray(u.items)?(O("items",["array"],t),gt("additionalItems",s("%d",u.items.length))):O("items",["object","boolean"],r=>(jt(S,s("0"),h=>ue(h,r,se("items"))),W({items:1/0}),null)),jr(r=>{jt(S,s("0"),(h,v)=>{r(h,()=>{W({dyn:{item:!0}}),ve({item:v})})})});const n=r=>{if(!T(r))return!1;if(r.enum||e.hasOwn(r,"const")||r.type&&(Array.isArray(r.type)?r.type:[r.type]).every(v=>z.includes(v)))return!0;if(r.$ref){const[h]=w(L,Te,r.$ref,Me())[0]||[];if(n(h))return!0}return!1},o=r=>r===!1||n(r),d=()=>!!(u.maxItems!==void 0||o(u.items)||Array.isArray(u.items)&&o(u.additionalItems));yt(!0,()=>{O("uniqueItems",["boolean"],r=>r===!1?null:(d()||ir("maxItems should be specified for non-primitive uniqueItems"),Object.assign(V,{unique:e.unique,deepEqual:e.deepEqual}),s("!unique(%s)",C)))})},Ke=t=>!de&&(N.required.includes(t)||De().some(n=>n.stat.required.includes(t))),hn=()=>{const t=s("Object.keys(%s).length",C);O("maxProperties",["natural"],n=>s("%s > %d",t,n)),O("minProperties",["natural"],n=>s("%s < %d",t,n)),Re("minProperties","maxProperties"),O("propertyNames",["object","boolean"],n=>(ut(S,(o,d)=>{const r=typeof n=="object"&&!n.$ref?{type:"string",...n}:n,h=Object.freeze({name:d,errorParent:o,type:"string"});ue(h,r,se("propertyNames"))}),null)),O("required",["array"],n=>{for(const o of n){if(Ke(o))continue;const d=_e(o);pe(c(ke(d)),{path:["required"],prop:d})}return W({required:n}),null});for(const n of["dependencies","dependentRequired","dependentSchemas"])n!=="dependencies"&&ce().dependentUnsupported||O(n,["object"],o=>{for(const d of Object.keys(o)){const r=typeof o[d]=="string"?[o[d]]:o[d],h=_e(d,Ke(d));if(Array.isArray(r)&&n!=="dependentSchemas"){const v=r.filter(U=>!Ke(U)).map(U=>ke(_e(U))),I=c(E(...v)),_={path:[n,d]};v.length===0||(h.checked?(pe(I,_),W({required:r})):pe(E(ke(h),I),_))}else Q(r)&&n!=="dependentRequired"?(We(n),p.if(h.checked?!0:ke(h),()=>{const v=ue(S,r,se(n,d),X);W(x({},v)),ve(v)})):xe(`Unexpected ${n} entry`)}return null});O("propertyDependencies",["object"],n=>{for(const[o,d]of Object.entries(n)){q(T(d),"propertyDependencies must be an object"),We("propertyDependencies");const r=_e(o,Ke(o));p.if(r.checked?!0:ke(r),()=>{for(const[h,v]of Object.entries(d))q(Q(v),"propertyDependencies must contain schemas"),p.if(Ot(i(r),h),()=>{const I=ue(S,v,se("propertyDependencies",o,h),X);W(x({},I)),ve(I)})})}return null}),O("properties",["object"],n=>{for(const o of Object.keys(n))ge!==o&&ue(_e(o,Ke(o)),n[o],se("properties",o));return W({properties:Object.keys(n)}),null}),yt(u.patternProperties,()=>{if(O("patternProperties",["object"],n=>(ut(S,(o,d)=>{for(const r of Object.keys(n))It(r,u.propertyNames||{}),p.if(Et(r,d),()=>{ue(o,n[r],se("patternProperties",r))})}),W({patterns:Object.keys(n)}),null)),u.additionalProperties||u.additionalProperties===!1){const n=Object.keys(u.properties||{}),o=Object.keys(u.patternProperties||{});u.additionalProperties===!1&&$r.push(()=>vr(n,o)),At("additionalProperties",r=>br(r,n,o))}}),ce().objectContains&&jr(n=>{ut(S,(o,d)=>{n(o,()=>{W({dyn:{properties:[!0]}}),ve({propertiesVars:[d]})})})})},yn=()=>{const t=O("const",["jsonval"],o=>c(Ot(C,o)));if(t&&!Ne)return!0;const n=O("enum",["array"],o=>{const d=o.filter(h=>h&&typeof h=="object"),r=o.filter(h=>!(h&&typeof h=="object"));return m(...[...r,...d].map(h=>Ot(C,h)))});return t||n},jr=t=>{O("contains",["object","boolean"],()=>{We("contains"),ce().objectContains&&Je("array")&&Je("object")&&Ae("possible type confusion in 'contains',","forbid 'object' or 'array'");const n=he("passes");p.write("let %s = 0",n);const o=Rt();return t((d,r)=>{const{sub:h}=Ce(o,d,u.contains,se("contains"));p.if(h,()=>{p.write("%s++",n),ce().containsEvaluates&&(q(!Fe,`Can't use removeAdditional with draft2020+ "contains"`),r())})}),O("minContains",["natural"],d=>s("%s < %d",n,d),{suberr:o})||pe(s("%s < 1",n),{path:["contains"],suberr:o}),O("maxContains",["natural"],d=>s("%s > %d",n,d)),Re("minContains","maxContains"),null})},gn=()=>{O("not",["object","boolean"],r=>Ce(null,S,r,se("not")).sub),u.not&&We("not"),(u.then||u.then===!1||u.else||u.else===!1||Ne)&&O("if",["object","boolean"],r=>{We("if/then/else");const{sub:h,delta:v}=Ce(null,S,r,se("if"),X);let I,_,U,K;return O("else",["object","boolean"],Z=>(I=()=>{U=ue(S,Z,se("else"),X),ve(U)},null)),O("then",["object","boolean"],Z=>(_=()=>{K=ue(S,Z,se("then"),X),ve(Y(v,K))},null)),!_&&!B(v)&&(_=()=>ve(v)),p.if(h,_,I),W(x(U||{},Y(v,K||{}))),null});const n=(r,h="allOf")=>{q(r.length>0,`${h} cannot be empty`);for(const[v,I]of Object.entries(r))W(ue(S,I,se(h,v),X));return null};O("allOf",["array"],r=>n(r));let o=null;O("discriminator",["object"],r=>{const h=new Set,v=(ee,Ze,Ge)=>q(ee,`[discriminator]: ${Ze}`,Ge),{propertyName:I,mapping:_,...U}=r,K=_e(I);v(I&&!u.oneOf!=!u.anyOf,"need propertyName, oneOf OR anyOf"),v(Object.keys(U).length===0,'only "propertyName" and "mapping" are supported');const Z=ee=>T(ee)?Object.keys(ee).length:null;return o=(ee,Ze)=>{const Ge=()=>{p.write("switch (%s) {",i(K));let Ye;for(const[vn,Xe]of Object.entries(ee)){const{const:zt,enum:xr,...$n}=(Xe.properties||{})[I]||{};let st=zt!==void 0?[zt]:xr;if(!st&&Xe.$ref){const[$e]=w(L,Te,Xe.$ref,Me())[0]||[];q(T($e),"failed to resolve $ref:",Xe.$ref);const it=($e.properties||{})[I]||{};st=it.const!==void 0?[it.const]:it.enum}const jn=Array.isArray(st)&&st.length>0;v(jn,"branches should have unique string const or enum values for [propertyName]");const On=Object.keys($n).length===0&&(!zt||!xr);v(On,"only const OR enum rules are allowed on [propertyName] in branches");for(const $e of st){const it=!_||e.hasOwn(_,$e)&&_[$e]===Xe.$ref;v(it,"mismatching mapping for",$e);const kn=typeof $e=="string"&&!h.has($e);v(kn,"const/enum values for [propertyName] should be unique strings"),h.add($e),p.write("case %j:",$e)}const qt=ue(S,Xe,se(Ze,vn),X,{constProp:I});ve(qt),Ye=Ye?x(Ye,qt):qt,p.write("break")}v(_===void 0||Z(_)===h.size,"mismatching mapping size"),W(Ye),p.write("default:"),Ie({path:[Ze]}),p.write("}")},nt=()=>{if(Ke(I))Ge();else{const Ye=["discriminator","propertyName"];p.if(ke(K),Ge,()=>Ie({path:Ye,prop:K}))}};return de||!e.deepEqual(N.type,["object"])?p.if(a.get("object")(C),nt,()=>Ie({path:["discriminator"]})):nt(),v(e.deepEqual(N.type,["object"]),"has to be checked for type:","object"),v(N.required.includes(I),"propertyName should be placed in required:",I),null},null});const d=(r,h)=>{const v=h.map(U=>U.type||(Array.isArray(U.const)?"array":typeof U.const)),I=v.filter(U=>!z.includes(U)&&U!=="array").length,_=v.filter(U=>!z.includes(U)&&U!=="object").length;(I>1||_>1)&&We(`${r}, use discriminator to make it certain`)};O("anyOf",["array"],r=>{if(q(r.length>0,"anyOf cannot be empty"),r.length===1)return n(r);if(o)return o(r,"anyOf");const h=Rt();if(!ur()){d("anyOf",r);const K=Object.entries(r).map(([Z,ee])=>Ce(h,S,ee,se("anyOf",Z),X));W(K.map(Z=>Z.delta).reduce((Z,ee)=>x(Z,ee))),pe(m(...K.map(({sub:Z})=>Z)),{path:["anyOf"],suberr:h});for(const{delta:Z,sub:ee}of K)p.if(ee,()=>ve(Z));return null}const v=r.filter(K=>e.hasOwn(K,"const")),I=r.filter(K=>!e.hasOwn(K,"const"));d("anyOf",I);const _=[...v,...I];let U;if(ce().exclusiveRefs){let K=()=>Ie({path:["anyOf"],suberr:h});for(const[Z,ee]of Object.entries(_).reverse()){const Ze=K;K=()=>{const{sub:Ge,delta:nt}=Ce(h,S,ee,se("anyOf",Z));p.if(c(Ge),Ze),U=U?x(U,nt):nt}}K()}else{const K=Object.entries(r).map(([Z,ee])=>Ce(h,S,ee,se("anyOf",Z),X));U=K.map(Z=>Z.delta).reduce((Z,ee)=>x(Z,ee)),pe(m(...K.map(({sub:Z})=>Z)),{path:["anyOf"],suberr:h})}return W(U),null}),O("oneOf",["array"],r=>{if(q(r.length>0,"oneOf cannot be empty"),r.length===1)return n(r);if(o)return o(r,"oneOf");d("oneOf",r);const h=he("passes");p.write("let %s = 0",h);const v=Rt();let I,_=0;const U=Object.entries(r).map(([K,Z])=>{!ye&&_++>1&&pe(s("%s > 1",h),{path:["oneOf"]});const ee=Ce(v,S,Z,se("oneOf",K),X);return p.if(ee.sub,()=>p.write("%s++",h)),I=I?x(I,ee.delta):ee.delta,ee});W(I),pe(s("%s !== 1",h),{path:["oneOf"]}),p.if(s("%s === 0",h),()=>gr(v));for(const K of U)p.if(K.sub,()=>ve(K.delta));return null})},He=(t,n,o)=>{const[d,r]=[p.size(),ze.size];p.if(fn(...n)?!0:o,t),(d!==p.size()||r!==ze.size)&&q(Je(...n),"Unexpected rules in type",u.type)},wn=()=>{if(N.items===1/0)u.unevaluatedItems===!1&&qe("unevaluatedItems","boolean");else if(u.unevaluatedItems||u.unevaluatedItems===!1)if(J(N).items){if(!A[Ee])throw new Error("[opt] Dynamic unevaluated tracing not enabled");const t=s("Math.max(%d, ...%s)",N.items,X.items),n=o=>s("%s.includes(%s)",X.item,o);gt("unevaluatedItems",t,ce().containsEvaluates?n:null)}else gt("unevaluatedItems",s("%d",N.items))},bn=()=>{yt(N.patterns.length>0||N.dyn.patterns.length>0||N.unknown,()=>{if(N.properties.includes(!0))u.unevaluatedProperties===!1&&qe("unevaluatedProperties","boolean");else if(u.unevaluatedProperties||u.unevaluatedProperties===!1){const t=n=>br(n,N.properties,N.patterns);if(J(N).properties){if(!A[Ee])throw new Error("[opt] Dynamic unevaluated tracing not enabled");V.propertyIn=e.propertyIn;const n=d=>s("!propertyIn(%s, %s)",d,X.props);At("unevaluatedProperties",d=>E(t(d),n(d)))}else u.unevaluatedProperties===!1&&vr(N.properties,N.patterns),At("unevaluatedProperties",t)}})},Or=()=>{if(ht!==null&&p.write("const %s = errorCount",ht),yn()){const t=[...a.keys()];if(W({properties:[!0],items:1/0,type:t,fullstring:!0}),!Ne){q(ze.size===0,"Unexpected keywords mixed with const or enum:",[...ze]);return}}He(dn,["number","integer"],a.get("number")(C)),He(pn,["string"],a.get("string")(C)),He(mn,["array"],a.get("array")(C)),He(hn,["object"],a.get("object")(C)),gn(),He(wn,["array"],a.get("array")(C)),He(bn,["object"],a.get("object")(C));for(const t of $r)t();dr(be,me.item,me.items,me.props)},kr=()=>{if(me.item&&p.write("const %s = []",me.item),me.items&&p.write("const %s = [0]",me.items),me.props&&p.write("const %s = [[], []]",me.props),O("$ref",["string"],n=>{const o=w(L,Te,n,Me()),[d,r,h]=o[0]||[];if(!d&&d!==!1&&(xe("failed to resolve $ref:",n),et))return null;const v=rt(d,r,h),I=d===$?Oe:v;if(!V[I])throw new Error("Unexpected: coherence check failed");if(!V[I][bt]&&d.type){const _=Array.isArray(d.type)?d.type:[d.type];W({type:_}),ct&&(Se.add(I),_.includes("array")&&W({items:1/0}),_.includes("object")&&W({properties:[!0]})),ft&&_.includes("string")&&(Se.add(I),W({fullstring:!0}))}return mt(v,{path:["$ref"]})}),ce().exclusiveRefs&&(q(!A[Ee],"unevaluated* is supported only on draft2019-09 and above"),u.$ref))return;O("$recursiveRef",["string"],n=>{if(!A[Qe])throw new Error("[opt] Recursive anchors are not enabled");q(n==="#",'Behavior of $recursiveRef is defined only for "#"');const o=w(L,Te,"#",Me()),[d,r,h]=o[0];tt(d.$recursiveAnchor,"$recursiveRef without $recursiveAnchor");const v=rt(d,r,h),I=d.$recursiveAnchor?s("(recursive || %s)",v):v;return mt(I,{path:["$recursiveRef"]})}),O("$dynamicRef",["string"],n=>{if(!A[Ue])throw new Error("[opt] Dynamic anchors are not enabled");tt(/^[^#]*#[a-zA-Z0-9_-]+$/.test(n),"Unsupported $dynamicRef format");const o=n.replace(/^[^#]+/,""),d=w(L,Te,n,Me());if(!d[0]&&!ce().bookending){tt(!1,"$dynamicRef bookending resolution failed (even though not required)"),V.dynamicResolve=e.dynamicResolve;const K=s("dynamicResolve(dynAnchors || [], %j)",o);return mt(K,{path:["$dynamicRef"]})}q(d[0],"$dynamicRef bookending resolution failed",n);const[r,h,v]=d[0],I=r.$dynamicAnchor&&`#${r.$dynamicAnchor}`===o;tt(I,"$dynamicRef without $dynamicAnchor in the same scope");const _=rt(r,h,v);V.dynamicResolve=e.dynamicResolve;const U=I?s("(dynamicResolve(dynAnchors || [], %j) || %s)",o,_):_;return mt(U,{path:["$dynamicRef"]})});let t=null;O("type",["string","array"],n=>{const o=Array.isArray(n)?n:[n];for(const r of o)q(typeof r=="string"&&a.has(r),"Unknown type:",r);if(S.type)return q(e.deepEqual(o,[S.type]),"One type allowed:",S.type),W({type:[S.type]}),null;if(hr(...o))return null;const d=o.filter(r=>Je(r));return d.length===0&&xe("No valid types possible"),W({type:o}),t=m(...d.map(r=>a.get(r)(C))),null}),t&&de?p.if(t,()=>Ie({path:["type"]}),Or):(t&&pe(t,{path:["type"]}),Or()),N.items<1/0&&u.maxItems<=N.items&&W({items:1/0})};if(u.default!==void 0&&Ht){Ve&&xe("Can not apply default value here (e.g. at root)");const t=cr("default","jsonval");p.if(ke(S),kr,()=>p.write("%s = %j",C,t))}else O("default",["jsonval"],null),p.if(Ve?!0:ke(S),kr);if(Le.length=an,Pe[0]&&Pe[Pe.length-1][0]===u&&Pe.pop(),lr&&u!==$&&p.write("dynLocal.shift()"),Hr||q(!p.optimizedOut,"some checks are never reachable"),pt){const t=["not","if","then","else"].includes(oe[oe.length-1]),n=["oneOf","anyOf","allOf"].includes(oe[oe.length-2]),o=["dependencies","dependentSchemas"].includes(oe[oe.length-2]),d=["propertyDependencies"].includes(oe[oe.length-3]);q(t||n||o||d,"Unexpected logical path")}else if(!oe.includes("not")&&((!($!==L&&u===$)||Se.has(Oe))&&(Se.delete(Oe),N.type||Ae("type"),Je("array")&&N.items!==1/0&&Ae(u.items?"additionalItems or unevaluatedItems":"items rule"),Je("object")&&!N.properties.includes(!0)&&Ae("additionalProperties or unevaluatedProperties"),!N.fullstring&&ft&&xe("[requireStringValidation] pattern, format or contentSchema should be specified for strings, use pattern: ^[\\s\\S]*$ to opt-out")),typeof u.propertyNames!="object"))for(const n of["additionalProperties","unevaluatedProperties"])u[n]&&Ae(`wild-card ${n}`,"requires propertyNames");return u.properties&&!u.required&&Ae("if properties is used, required"),q(ze.size===0||Ne,"Unprocessed keywords:",[...ze]),{stat:N,local:me}},{stat:xt,local:dt}=kt(s("validate.errors"),[],{name:P("data")},$,[]);if(Se.has(Oe))throw new Error("Unexpected: unvalidated cyclic ref");if(A[Ee]&&(J(xt).items||J(xt).properties)){if(!dt)throw new Error("Failed to trace dynamic properties");p.write("validate.evaluatedDynamic = [%s, %s, %s]",dt.item,dt.items,dt.props)}return de?p.write("return errorCount === 0"):p.write("return true"),p.write("}"),et||(lt=p.makeFunction(V),delete V[Oe],V[Oe]=lt),V[Oe][bt]=xt,Oe},at=($,L)=>{if(!Array.isArray($))throw new Error("Expected an array of schemas");try{const A=Object.create(null),{getref:V}=f(A);Se.clear(),Be.clear();const ae=$.map(je=>V(je)||Kt(je,je,L,A));if(Se.size!==0)throw new Error("Unexpected: not all refs are validated");return{scope:A,refs:ae}}catch(A){if(!L[Ee]&&A.message==="[opt] Dynamic unevaluated tracing not enabled")return at($,{...L,[Ee]:!0});if(!L[Ue]&&A.message==="[opt] Dynamic anchors are not enabled")return at($,{...L,[Ue]:!0});if(!L[Qe]&&A.message==="[opt] Recursive anchors are not enabled")return at($,{...L,[Qe]:!0});throw A}finally{Se.clear(),Be.clear()}};return Lt={compile:at},Lt}var Vt,_r;function Bn(){if(_r)return Vt;_r=1;const s=Tr(),{buildSchemas:P}=Vr(),{compile:E}=Qn(),{deepEqual:c}=Jt(),m=g=>function e(f){if(!c(f,JSON.parse(JSON.stringify(f))))return e.errors=[{instanceLocation:"#",error:"not JSON compatible"}],!1;const i=g(f);return e.errors=g.errors,i},y=g=>e=>c(e,JSON.parse(JSON.stringify(e)))&&g(e),w=(g,{parse:e=!1,multi:f=!1,jsonCheck:i=!1,isJSON:a=!1,schemas:l=[],...b}={})=>{if(i&&a)throw new Error("Can not specify both isJSON and jsonCheck options");if(e&&(i||a))throw new Error("jsonCheck and isJSON options are not applicable in parser mode");const k=e?"strong":"default",D=a||i||e,F=f?g:[g],Y={mode:k,...b,schemas:P(l,F),isJSON:D},{scope:x,refs:ie}=E(F,Y);if(b.dryRun)return;if(b.lint)return x.lintErrors;const J=s();if(e?x.parseWrap=b.includeErrors?M:G:i&&(x.deepEqual=c,x.jsonCheckWrap=b.includeErrors?m:y),f){J.write("[");for(const j of ie.slice(0,-1))J.write("%s,",j);ie.length>0&&J.write("%s",ie[ie.length-1]),J.write("]"),e?J.write(".map(parseWrap)"):i&&J.write(".map(jsonCheckWrap)")}else e?J.write("parseWrap(%s)",ie[0]):i?J.write("jsonCheckWrap(%s)",ie[0]):J.write("%s",ie[0]);const we=J.makeFunction(x);return we.toModule=({semi:j=!0}={})=>J.makeModule(x)+(j?";":""),we.toJSON=()=>g,we},M=g=>e=>{if(typeof e!="string")return{valid:!1,error:"Input is not a string"};try{const f=JSON.parse(e);if(!g(f)){const{keywordLocation:i,instanceLocation:a}=g.errors[0];return{valid:!1,error:`JSON validation failed for ${i.slice(i.lastIndexOf("/")+1)} at ${a}`,errors:g.errors}}return{valid:!0,value:f}}catch({message:f}){return{valid:!1,error:f}}},G=g=>e=>{if(typeof e!="string")return{valid:!1};try{const f=JSON.parse(e);return g(f)?{valid:!0,value:f}:{valid:!1}}catch{return{valid:!1}}};return Vt={validator:w,parser:function(g,{parse:e=!0,...f}={}){if(!e)throw new Error("can not disable parse in parser");return w(g,{parse:e,...f})},lint:function(g,{lint:e=!0,...f}={}){if(!e)throw new Error("can not disable lint option in lint()");return w(g,{lint:e,...f})}},Vt}var es=Bn();function ts(s){let P=!1,E=new WeakRef({});const c=y=>s(P?Ln(y,Cr):y,E.deref());let m=Wt(new WeakMap,c);return(y,w)=>(P=y!==w,E.deref()!==w&&(E=new WeakRef(w),m=Wt(new WeakMap,c)),m(y))}function rs(s){const P=new WeakMap,E={},c=Wt(P,m=>s(m,E));return m=>c(m.schema)}function ns({createSchemaValidator:s,valueToJSON:P}){return{isValid(E,c,m){return typeof E=="boolean"?E:s(E,c)(P(m))}}}function ss(s){const P=Vn(s);return{validateFormValue(E,c){const m=s.createSchemaValidator(E,E);return m(s.valueToJSON(c)),P(E,m.errors)}}}function is({createFieldSchemaValidator:s,valueToJSON:P}){return{validateFieldValue(E,c){const m=s(E);return m(P(c)),Wn(E,m.errors)}}}function os({factory:s=(y,w)=>es.validator(y,{...Gn,schemas:{[Cr]:w}}),createSchemaValidator:P=ts(s),createFieldSchemaValidator:E=rs(s),valueToJSON:c=y=>y,...m}={}){const y={...m,valueToJSON:c,createSchemaValidator:P,createFieldSchemaValidator:E};return Object.assign(ns(y),ss(y),is(y))}var as=En("<!> <pre> </pre>",1);function Rs(s,P){xn(P,!1);const E=os({uiSchema:Er}),c=Fn({...Jn,schema:Hn,uiSchema:Er,validator:E,fieldsValidationMode:_n|Cn|Un,initialValue:Kn});Dn();var m=as(),y=Sn(m);Tn(y,{get form(){return c},novalidate:!0});var w=zn(y,2),M=Nn(w,!0);Pn(w),In(G=>Mn(M,G),[()=>JSON.stringify(c.value,null,2)],qn),Rn(s,m),An()}export{Rs as default};
