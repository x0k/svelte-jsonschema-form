var g;function _(e){return{lang:e?.lang??g?.lang,message:e?.message,abortEarly:e?.abortEarly??g?.abortEarly,abortPipeEarly:e?.abortPipeEarly??g?.abortPipeEarly}}var q;function v(e){return q?.get(e)}var I;function w(e){return I?.get(e)}var E;function M(e,r){return E?.get(e)?.get(r)}function $(e){const r=typeof e;return r==="string"?`"${e}"`:r==="number"||r==="bigint"||r==="boolean"?`${e}`:r==="object"||r==="function"?(e&&Object.getPrototypeOf(e)?.constructor?.name)??"null":r}function o(e,r,t,i,u){const n=u&&"input"in u?u.input:t.value,s=u?.expected??e.expects??null,p=u?.received??$(n),f={kind:e.kind,type:e.type,input:n,expected:s,received:p,message:`Invalid ${r}: ${s?`Expected ${s} but r`:"R"}eceived ${p}`,requirement:e.requirement,path:u?.path,issues:u?.issues,lang:i.lang,abortEarly:i.abortEarly,abortPipeEarly:i.abortPipeEarly},l=e.kind==="schema",a=u?.message??e.message??M(e.reference,f.lang)??(l?w(f.lang):null)??i.message??v(f.lang);a!==void 0&&(f.message=typeof a=="function"?a(f):a),l&&(t.typed=!1),t.issues?t.issues.push(f):t.issues=[f]}function k(e){return{version:1,vendor:"valibot",validate(r){return e["~run"]({value:r},_())}}}function P(e,r){const t=[...new Set(e)];return t.length>1?`(${t.join(` ${r} `)})`:t[0]??"never"}function O(e,r){return{kind:"validation",type:"check",reference:O,async:!1,expects:null,requirement:e,message:r,"~run"(t,i){return t.typed&&!this.requirement(t.value)&&o(this,"input",t,i),t}}}function T(e,r){return{kind:"validation",type:"max_length",reference:T,async:!1,expects:`<=${e}`,requirement:e,message:r,"~run"(t,i){return t.typed&&t.value.length>this.requirement&&o(this,"length",t,i,{received:`${t.value.length}`}),t}}}function L(e,r){return{kind:"validation",type:"min_length",reference:L,async:!1,expects:`>=${e}`,requirement:e,message:r,"~run"(t,i){return t.typed&&t.value.length<this.requirement&&o(this,"length",t,i,{received:`${t.value.length}`}),t}}}function J(e,r){return{kind:"validation",type:"regex",reference:J,async:!1,expects:`${e}`,requirement:e,message:r,"~run"(t,i){return t.typed&&!this.requirement.test(t.value)&&o(this,"format",t,i),t}}}function N(e,r,t){return typeof e.fallback=="function"?e.fallback(r,t):e.fallback}function c(e,r,t){return typeof e.default=="function"?e.default(r,t):e.default}function R(e,r){return{kind:"schema",type:"array",reference:R,expects:"Array",async:!1,item:e,message:r,get"~standard"(){return k(this)},"~run"(t,i){const u=t.value;if(Array.isArray(u)){t.typed=!0,t.value=[];for(let n=0;n<u.length;n++){const s=u[n],p=this.item["~run"]({value:s},i);if(p.issues){const f={type:"array",origin:"value",input:u,key:n,value:s};for(const l of p.issues)l.path?l.path.unshift(f):l.path=[f],t.issues?.push(l);if(t.issues||(t.issues=p.issues),i.abortEarly){t.typed=!1;break}}p.typed||(t.typed=!1),t.value.push(p.value)}}else o(this,"type",t,i);return t}}}function D(e){return{kind:"schema",type:"boolean",reference:D,expects:"boolean",async:!1,message:e,get"~standard"(){return k(this)},"~run"(r,t){return typeof r.value=="boolean"?r.typed=!0:o(this,"type",r,t),r}}}function G(e,r){return{kind:"schema",type:"object",reference:G,expects:"Object",async:!1,entries:e,message:r,get"~standard"(){return k(this)},"~run"(t,i){const u=t.value;if(u&&typeof u=="object"){t.typed=!0,t.value={};for(const n in this.entries){const s=this.entries[n];if(n in u||(s.type==="exact_optional"||s.type==="optional"||s.type==="nullish")&&s.default!==void 0){const p=n in u?u[n]:c(s),f=s["~run"]({value:p},i);if(f.issues){const l={type:"object",origin:"value",input:u,key:n,value:p};for(const a of f.issues)a.path?a.path.unshift(l):a.path=[l],t.issues?.push(a);if(t.issues||(t.issues=f.issues),i.abortEarly){t.typed=!1;break}}f.typed||(t.typed=!1),t.value[n]=f.value}else if(s.fallback!==void 0)t.value[n]=N(s);else if(s.type!=="exact_optional"&&s.type!=="optional"&&s.type!=="nullish"&&(o(this,"key",t,i,{input:void 0,expected:`"${n}"`,path:[{type:"object",origin:"key",input:u,key:n,value:u[n]}]}),i.abortEarly))break}}else o(this,"type",t,i);return t}}}function m(e,r){return{kind:"schema",type:"optional",reference:m,expects:`(${e.expects} | undefined)`,async:!1,wrapped:e,default:r,get"~standard"(){return k(this)},"~run"(t,i){return t.value===void 0&&(this.default!==void 0&&(t.value=c(this,t,i)),t.value===void 0)?(t.typed=!0,t):this.wrapped["~run"](t,i)}}}function z(e,r){return{kind:"schema",type:"picklist",reference:z,expects:P(e.map($),"|"),async:!1,options:e,message:r,get"~standard"(){return k(this)},"~run"(t,i){return this.options.includes(t.value)?t.typed=!0:o(this,"type",t,i),t}}}function C(e){return{kind:"schema",type:"string",reference:C,expects:"string",async:!1,message:e,get"~standard"(){return k(this)},"~run"(r,t){return typeof r.value=="string"?r.typed=!0:o(this,"type",r,t),r}}}function K(e,r){const t={};for(const i in e.entries)t[i]=m(e.entries[i]);return{...e,entries:t,get"~standard"(){return k(this)}}}function Q(...e){return{...e[0],pipe:e,get"~standard"(){return k(this)},"~run"(r,t){for(const i of e)if(i.kind!=="metadata"){if(r.issues&&(i.kind==="schema"||i.kind==="transformation")){r.typed=!1;break}(!r.issues||!t.abortEarly&&!t.abortPipeEarly)&&(r=i["~run"](r,t))}return r}}}function U(e,r,t){const i=e["~run"]({value:r},_(t));return{typed:i.typed,success:!i.issues,output:i.value,issues:i.issues}}function d(e,r){return e?(e.push(r),e):[r]}function b(e,r){switch(r?.errorMode){case"ignore":break;case"warn":{console.warn(e);break}default:throw new Error(e)}}function F(e,r,t){if(t?.ignoreActions?.includes(r.type))return e;let i;switch(r.type){case"base64":{e.contentEncoding="base64";break}case"bic":case"cuid2":case"decimal":case"digits":case"emoji":case"hexadecimal":case"hex_color":case"nanoid":case"octal":case"ulid":{e.pattern=r.requirement.source;break}case"description":{e.description=r.description;break}case"email":{e.format="email";break}case"empty":{e.type==="array"?e.maxItems=0:(e.type!=="string"&&(i=d(i,`The "${r.type}" action is not supported on type "${e.type}".`)),e.maxLength=0);break}case"entries":{e.minProperties=r.requirement,e.maxProperties=r.requirement;break}case"integer":{e.type="integer";break}case"ipv4":{e.format="ipv4";break}case"ipv6":{e.format="ipv6";break}case"iso_date":{e.format="date";break}case"iso_date_time":case"iso_timestamp":{e.format="date-time";break}case"iso_time":{e.format="time";break}case"length":{e.type==="array"?(e.minItems=r.requirement,e.maxItems=r.requirement):(e.type!=="string"&&(i=d(i,`The "${r.type}" action is not supported on type "${e.type}".`)),e.minLength=r.requirement,e.maxLength=r.requirement);break}case"max_entries":{e.maxProperties=r.requirement;break}case"max_length":{e.type==="array"?e.maxItems=r.requirement:(e.type!=="string"&&(i=d(i,`The "${r.type}" action is not supported on type "${e.type}".`)),e.maxLength=r.requirement);break}case"max_value":{e.type!=="number"&&(i=d(i,`The "max_value" action is not supported on type "${e.type}".`)),e.maximum=r.requirement;break}case"metadata":{typeof r.metadata.title=="string"&&(e.title=r.metadata.title),typeof r.metadata.description=="string"&&(e.description=r.metadata.description),Array.isArray(r.metadata.examples)&&(e.examples=r.metadata.examples);break}case"min_entries":{e.minProperties=r.requirement;break}case"min_length":{e.type==="array"?e.minItems=r.requirement:(e.type!=="string"&&(i=d(i,`The "${r.type}" action is not supported on type "${e.type}".`)),e.minLength=r.requirement);break}case"min_value":{e.type!=="number"&&(i=d(i,`The "min_value" action is not supported on type "${e.type}".`)),e.minimum=r.requirement;break}case"multiple_of":{e.multipleOf=r.requirement;break}case"non_empty":{e.type==="array"?e.minItems=1:(e.type!=="string"&&(i=d(i,`The "${r.type}" action is not supported on type "${e.type}".`)),e.minLength=1);break}case"regex":{r.requirement.flags&&(i=d(i,"RegExp flags are not supported by JSON Schema.")),e.pattern=r.requirement.source;break}case"title":{e.title=r.title;break}case"url":{e.format="uri";break}case"uuid":{e.format="uuid";break}case"value":{e.const=r.requirement;break}default:i=d(i,`The "${r.type}" action cannot be converted to JSON Schema.`)}if(t?.overrideAction){const u=t.overrideAction({valibotAction:r,jsonSchema:e,errors:i});if(u)return{...u}}if(i)for(const u of i)b(u,t);return e}function x(e){return e.flatMap(r=>"pipe"in r?x(r.pipe):r)}let V=0;function y(e,r,t,i,u=!1){if(!u){const s=i.referenceMap.get(r);if(s){if(e.$ref=`#/$defs/${s}`,t?.overrideRef){const p=t.overrideRef({...i,referenceId:s,valibotSchema:r,jsonSchema:e});p&&(e.$ref=p)}return e}}if("pipe"in r){const s=x(r.pipe);let p=0,f=s.length-1;if(t?.typeMode==="input"){const l=s.slice(1).findIndex(a=>a.kind==="schema"||a.kind==="transformation"&&(a.type==="find_item"||a.type==="parse_json"||a.type==="raw_transform"||a.type==="reduce_items"||a.type==="stringify_json"||a.type==="transform"));l!==-1&&(f=l)}else if(t?.typeMode==="output"){const l=s.findLastIndex(a=>a.kind==="schema");l!==-1&&(p=l)}for(let l=p;l<=f;l++){const a=s[l];a.kind==="schema"?(l>p&&b('Set the "typeMode" config to "input" or "output" to convert pipelines with multiple schemas.',t),e=y(e,a,t,i,!0)):e=F(e,a,t)}return e}let n;switch(r.type){case"boolean":{e.type="boolean";break}case"null":{e.type="null";break}case"number":{e.type="number";break}case"string":{e.type="string";break}case"array":{e.type="array",e.items=y({},r.item,t,i);break}case"tuple":case"tuple_with_rest":case"loose_tuple":case"strict_tuple":{e.type="array",e.items=[],e.minItems=r.items.length;for(const s of r.items)e.items.push(y({},s,t,i));r.type==="tuple_with_rest"?e.additionalItems=y({},r.rest,t,i):r.type==="strict_tuple"&&(e.additionalItems=!1);break}case"object":case"object_with_rest":case"loose_object":case"strict_object":{e.type="object",e.properties={},e.required=[];for(const s in r.entries){const p=r.entries[s];e.properties[s]=y({},p,t,i),p.type!=="nullish"&&p.type!=="optional"&&e.required.push(s)}r.type==="object_with_rest"?e.additionalProperties=y({},r.rest,t,i):r.type==="strict_object"&&(e.additionalProperties=!1);break}case"record":{"pipe"in r.key&&(n=d(n,'The "record" schema with a schema for the key that contains a "pipe" cannot be converted to JSON Schema.')),r.key.type!=="string"&&(n=d(n,`The "record" schema with the "${r.key.type}" schema for the key cannot be converted to JSON Schema.`)),e.type="object",e.additionalProperties=y({},r.value,t,i);break}case"any":case"unknown":break;case"nullable":case"nullish":{e.anyOf=[y({},r.wrapped,t,i),{type:"null"}],r.default!==void 0&&(e.default=c(r));break}case"exact_optional":case"optional":case"undefinedable":{e=y(e,r.wrapped,t,i),r.default!==void 0&&(e.default=c(r));break}case"literal":{typeof r.literal!="boolean"&&typeof r.literal!="number"&&typeof r.literal!="string"&&(n=d(n,'The value of the "literal" schema is not JSON compatible.')),e.const=r.literal;break}case"enum":{e.enum=r.options;break}case"picklist":{r.options.some(s=>typeof s!="number"&&typeof s!="string")&&(n=d(n,'An option of the "picklist" schema is not JSON compatible.')),e.enum=r.options;break}case"union":case"variant":{e.anyOf=r.options.map(s=>y({},s,t,i));break}case"intersect":{e.allOf=r.options.map(s=>y({},s,t,i));break}case"lazy":{let s=i.getterMap.get(r.getter);s||(s=r.getter(void 0),i.getterMap.set(r.getter,s));let p=i.referenceMap.get(s);if(p||(p=`${V++}`,i.referenceMap.set(s,p),i.definitions[p]=y({},s,t,i,!0)),e.$ref=`#/$defs/${p}`,t?.overrideRef){const f=t.overrideRef({...i,referenceId:p,valibotSchema:s,jsonSchema:e});f&&(e.$ref=f)}break}default:n=d(n,`The "${r.type}" schema cannot be converted to JSON Schema.`)}if(t?.overrideSchema){const s=t.overrideSchema({...i,referenceId:i.referenceMap.get(r),valibotSchema:r,jsonSchema:e,errors:n});if(s)return{...s}}if(n)for(const s of n)b(s,t);return e}let B;function H(){return B}function W(e,r){const t={definitions:{},referenceMap:new Map,getterMap:new Map},i=r?.definitions??H();if(i){for(const n in i)t.referenceMap.set(i[n],n);for(const n in i)t.definitions[n]=y({},i[n],r,t,!0)}const u=y({$schema:"http://json-schema.org/draft-07/schema#"},e,r,t);return t.referenceMap.size&&(u.$defs=t.definitions),u}export{m as a,R as b,L as c,D as d,z as e,O as f,K as g,U as h,T as m,G as o,Q as p,J as r,C as s,W as t};
