import{t as J,e as Q}from"./bundle-mjs.CJvxXMcu.js";var Y=/\s+/g,Z=t=>typeof t!="string"||!t?t:t.replace(Y," ").trim(),P=(...t)=>{const s=[],n=e=>{if(!e&&e!==0&&e!==0n)return;if(Array.isArray(e)){for(let r=0,m=e.length;r<m;r++)n(e[r]);return}const i=typeof e;if(i==="string"||i==="number"||i==="bigint"){if(i==="number"&&e!==e)return;s.push(String(e))}else if(i==="object"){const r=Object.keys(e);for(let m=0,O=r.length;m<O;m++){const S=r[m];e[S]&&s.push(S)}}};for(let e=0,i=t.length;e<i;e++){const r=t[e];r!=null&&n(r)}return s.length>0?Z(s.join(" ")):void 0},q=t=>t===!1?"false":t===!0?"true":t===0?"0":t,g=t=>{if(!t||typeof t!="object")return!0;for(const s in t)return!1;return!0},ee=(t,s)=>{if(t===s)return!0;if(!t||!s)return!1;const n=Object.keys(t),e=Object.keys(s);if(n.length!==e.length)return!1;for(let i=0;i<n.length;i++){const r=n[i];if(!e.includes(r)||t[r]!==s[r])return!1}return!0},te=(t,s)=>{for(const n in s)if(Object.prototype.hasOwnProperty.call(s,n)){const e=s[n];n in t?t[n]=P(t[n],e):t[n]=e}return t},U=(t,s)=>{for(let n=0;n<t.length;n++){const e=t[n];Array.isArray(e)?U(e,s):e&&s.push(e)}},W=(...t)=>{const s=[];U(t,s);const n=[];for(let e=0;e<s.length;e++)s[e]&&n.push(s[e]);return n},B=(t,s)=>{const n={};for(const e in t){const i=t[e];if(e in s){const r=s[e];Array.isArray(i)||Array.isArray(r)?n[e]=W(r,i):typeof i=="object"&&typeof r=="object"&&i&&r?n[e]=B(i,r):n[e]=r+" "+i}else n[e]=i}for(const e in s)e in t||(n[e]=s[e]);return n},re={twMerge:!0,twMergeConfig:{}};function se(){let t=null,s={},n=!1;return{get cachedTwMerge(){return t},set cachedTwMerge(e){t=e},get cachedTwMergeConfig(){return s},set cachedTwMergeConfig(e){s=e},get didTwMergeConfigChange(){return n},set didTwMergeConfigChange(e){n=e},reset(){t=null,s={},n=!1}}}var w=se(),ne=t=>{const s=(e,i)=>{const{extend:r=null,slots:m={},variants:O={},compoundVariants:S=[],compoundSlots:T=[],defaultVariants:F={}}=e,M={...re,...i},G=r?.base?P(r.base,e?.base):e?.base,d=r?.variants&&!g(r.variants)?B(O,r.variants):O,j=r?.defaultVariants&&!g(r.defaultVariants)?{...r.defaultVariants,...F}:F;!g(M.twMergeConfig)&&!ee(M.twMergeConfig,w.cachedTwMergeConfig)&&(w.didTwMergeConfigChange=!0,w.cachedTwMergeConfig=M.twMergeConfig);const x=g(r?.slots),K=g(m)?{}:{base:P(e?.base,x&&r?.base),...m},N=x?K:te({...r?.slots},g(K)?{base:e?.base}:K),A=g(r?.compoundVariants)?S:W(r?.compoundVariants,S),v=h=>{if(g(d)&&g(m)&&x)return t(G,h?.class,h?.className)(M);if(A&&!Array.isArray(A))throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof A}`);if(T&&!Array.isArray(T))throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof T}`);const R=(a,l=d,o=null,f=null)=>{const c=l[a];if(!c||g(c))return null;const u=f?.[a]??h?.[a];if(u===null)return null;const y=q(u);if(typeof y=="object")return null;const b=j?.[a],p=y??q(b);return c[p||"false"]},z=()=>{if(!d)return null;const a=Object.keys(d),l=[];for(let o=0;o<a.length;o++){const f=R(a[o],d);f&&l.push(f)}return l},D=(a,l)=>{if(!d||typeof d!="object")return null;const o=[];for(const f in d){const c=R(f,d,a,l),u=a==="base"&&typeof c=="string"?c:c&&c[a];u&&o.push(u)}return o},_={};for(const a in h){const l=h[a];l!==void 0&&(_[a]=l)}const L=(a,l)=>{const o=typeof h?.[a]=="object"?{[a]:h[a]?.initial}:{};return{...j,..._,...o,...l}},$=(a=[],l)=>{const o=[],f=a.length;for(let c=0;c<f;c++){const{class:u,className:y,...b}=a[c];let p=!0;const C=L(null,l);for(const k in b){const V=b[k],E=C[k];if(Array.isArray(V)){if(!V.includes(E)){p=!1;break}}else{if((V==null||V===!1)&&(E==null||E===!1))continue;if(E!==V){p=!1;break}}}p&&(u&&o.push(u),y&&o.push(y))}return o},H=a=>{const l=$(A,a);if(!Array.isArray(l))return l;const o={},f=t;for(let c=0;c<l.length;c++){const u=l[c];if(typeof u=="string")o.base=f(o.base,u)(M);else if(typeof u=="object")for(const y in u)o[y]=f(o[y],u[y])(M)}return o},I=a=>{if(T.length<1)return null;const l={},o=L(null,a);for(let f=0;f<T.length;f++){const{slots:c=[],class:u,className:y,...b}=T[f];if(!g(b)){let p=!0;for(const C in b){const k=o[C],V=b[C];if(k===void 0||(Array.isArray(V)?!V.includes(k):V!==k)){p=!1;break}}if(!p)continue}for(let p=0;p<c.length;p++){const C=c[p];l[C]||(l[C]=[]),l[C].push([u,y])}}return l};if(!g(m)||!x){const a={};if(typeof N=="object"&&!g(N)){const l=t;for(const o in N)a[o]=f=>{const c=H(f),u=I(f);return l(N[o],D(o,f),c?c[o]:void 0,u?u[o]:void 0,f?.class,f?.className)(M)}}return a}return t(G,z(),$(A),h?.class,h?.className)(M)},X=()=>{if(!(!d||typeof d!="object"))return Object.keys(d)};return v.variantKeys=X(),v.extend=r,v.base=G,v.slots=N,v.variants=d,v.defaultVariants=j,v.compoundSlots=T,v.compoundVariants=A,v};return{tv:s,createTV:e=>(i,r)=>s(i,r?B(e,r):e)}},ae=t=>g(t)?J:Q({...t,extend:{theme:t.theme,classGroups:t.classGroups,conflictingClassGroupModifiers:t.conflictingClassGroupModifiers,conflictingClassGroups:t.conflictingClassGroups,...t.extend}}),oe=(t,s)=>{const n=P(t);return!n||!(s?.twMerge??!0)?n:((!w.cachedTwMerge||w.didTwMergeConfigChange)&&(w.didTwMergeConfigChange=!1,w.cachedTwMerge=ae(w.cachedTwMergeConfig)),w.cachedTwMerge(n)||void 0)},le=(...t)=>s=>oe(t,s),{tv:ce}=ne(le);export{ce as t};
