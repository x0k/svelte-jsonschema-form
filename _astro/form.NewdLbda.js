import"./each.C1y4Ttji.js";import{p as kn,e as xn,t as En,b as Sn,a as In,s as Rn,h as An,f as zn,c as Mn,r as qn}from"./render.-l4jZV6X.js";import{ah as Dr,aj as Nn,ak as Pn,b as Dn,e as _n,O as Cn,k as Fn}from"./definitions.DZ-4uMDD.js";import{c as Un}from"./en.CGib5yfB.js";import{B as Tn}from"./basic-form.CjYyW7av.js";import{h as Ln}from"./checkboxes-include.CskT9z0Q.js";import{t as Vn,a as Wn}from"./errors.CTrnG6mP.js";import{d as Jn}from"./defaults.Cl93uFtH.js";import{i as Kn,u as Hn,s as Zn}from"./index.BPQVTpeN.js";import"./_commonjsHelpers.DaWZu8wl.js";import"./snippet.DkaeJbdM.js";import"./file.CGRfUJOb.js";import"./form.cPqLzU63.js";import"./content.EGz9FIh_.js";import"./submit-button.Cg1SalSp.js";import"./assert.COQe5kxu.js";import"./file-include.AVWST3UT.js";const Gn={"data-url":/^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/},Yn={includeErrors:!0,allErrors:!0,$schemaDefault:"http://json-schema.org/draft-07/schema",extraFormats:!0,formats:Gn};var qt,xr;function wt(){if(xr)return qt;xr=1;class n extends String{}const x=new Set(["<",">","<=",">="]),S=e=>`\\u${e.toString(16).padStart(4,"0")}`,a=e=>{if([1/0,-1/0,NaN,void 0,null].includes(e))return`${e}`;if(!["string","boolean","number"].includes(typeof e)){if(typeof e!="object")throw new Error("Unexpected value type");const i=Object.getPrototypeOf(e);if(!(i===Array.prototype&&Array.isArray(e)||i===Object.prototype))throw new Error("Unexpected object given as value")}return JSON.stringify(e).replace(/([{,])"__proto__":/g,'$1["__proto__"]:').replace(/[^\\]"__proto__":/g,()=>{throw new Error("Unreachable")}).replace(/[\u2028\u2029]/g,i=>S(i.charCodeAt(0)))},y=(e,...f)=>{const i=e.replace(/%[%drscjw]/g,c=>{if(c==="%%")return"%";if(f.length===0)throw new Error("Unexpected arguments count");const l=f.shift();switch(c){case"%d":if(typeof l=="number")return l;throw new Error("Expected a number");case"%r":if(l instanceof RegExp)return y("new RegExp(%j, %j)",l.source,l.flags);throw new Error("Expected a RegExp instance");case"%s":if(l instanceof n)return l;throw new Error("Expected a safe string");case"%c":if(x.has(l))return l;throw new Error("Expected a compare op");case"%j":return a(l);case"%w":if(Number.isInteger(l)&&l>=0)return" ".repeat(l);throw new Error("Expected a non-negative integer for indentation")}throw new Error("Unreachable")});if(f.length!==0)throw new Error("Unexpected arguments count");return new n(i)},w=e=>{if(!/^[a-z][a-z0-9_]*$/i.test(e))throw new Error("Does not look like a safe id");return new n(e)},h=e=>(...f)=>{if(!f.every(i=>i instanceof n))throw new Error("Unsafe arguments");return new n(e(...f))},z=e=>/^[a-z][a-z0-9_().]*$/i.test(e)||/^\([^()]+\)$/i.test(e)?e:y("(%s)",e),Q=h((...e)=>e.some(f=>`${f}`=="true")?"true":e.join(" || ")||"false"),ne=h((...e)=>e.some(f=>`${f}`=="false")?"false":e.join(" && ")||"true"),H=e=>`${e}`=="true"?w("false"):`${e}`=="false"?w("true"):y("!%s",z(e));return qt={format:y,safe:w,safeand:ne,safenot:H,safenotor:(...e)=>H(Q(...e))},qt}var Nt,Er;function _r(){if(Er)return Nt;Er=1;const{safe:n}=wt(),x=new WeakMap;return Nt={scopeMethods:a=>{x.has(a)||x.set(a,{sym:new Map,ref:new Map,format:new Map,pattern:new Map});const y=x.get(a),w=g=>{y.sym.get(g)||y.sym.set(g,0);const e=y.sym.get(g);return y.sym.set(g,e+1),n(`${g}${e}`)},h=g=>{if(y.pattern.has(g))return y.pattern.get(g);const e=w("pattern");return a[e]=new RegExp(g,"u"),y.pattern.set(g,e),e};return y.loop||(y.loop="ijklmnopqrstuvxyz".split("")),{gensym:w,genpattern:h,genloop:()=>{const g=y.loop.shift();return y.loop.push(`${g}${g[0]}`),n(g)},getref:g=>y.ref.get(g),genref:g=>{const e=w("ref");return y.ref.set(g,e),e},genformat:g=>{let e=y.format.get(g);return e||(e=w("format"),a[e]=g,y.format.set(g,e)),e}}}},Nt}var Pt,Sr;function Wt(){if(Sr)return Pt;Sr=1;const n=e=>/[\uD800-\uDFFF]/.test(e)?[...e].length:e.length,x=(e,f,i,c)=>{if(e%f===0)return!0;let l=e*i;if((l===1/0||l===-1/0)&&(l=e),l%c===0)return!0;const b=Math.floor(l+.5);return b/i===e&&b%c===0},S=(e,f)=>{if(e===f)return!0;if(!e||!f||typeof e!=typeof f||e!==f&&typeof e!="object")return!1;const i=Object.getPrototypeOf(e);if(i!==Object.getPrototypeOf(f))return!1;if(i===Array.prototype)return!Array.isArray(e)||!Array.isArray(f)||e.length!==f.length?!1:e.every((c,l)=>S(c,f[l]));if(i===Object.prototype){const[c,l]=[Object.keys(e),Object.keys(f)];return c.length!==l.length?!1:new Set([...c,...l]).size===c.length&&c.every(k=>S(e[k],f[k]))}return!1},a=e=>{if(e.length<2)return!0;if(e.length===2)return!S(e[0],e[1]);const f=[],i=e.length>20?new Set:null;let c=0,l=0;for(const b of e){if(typeof b=="object")f.push(b);else if(i){if(i.add(b),i.size!==++c)return!1}else if(e.indexOf(b,l+1)!==-1)return!1;l++}for(let b=1;b<f.length;b++)for(let k=0;k<b;k++)if(S(f[b],f[k]))return!1;return!0},y=e=>{if(typeof Buffer<"u")return Buffer.from(e,"base64").toString("utf-8");const f=atob(e);return new TextDecoder("utf-8").decode(new Uint8Array(f.length).map((i,c)=>f.charCodeAt(c)))},w=Function.prototype.call.bind(Object.prototype.hasOwnProperty);w[Symbol.for("toJayString")]="Function.prototype.call.bind(Object.prototype.hasOwnProperty)";const h=e=>/~\//.test(e)?`${e}`.replace(/~/g,"~0").replace(/\//g,"~1"):e;return Pt={stringLength:n,isMultipleOf:x,deepEqual:S,unique:a,deBase64:y,hasOwn:w,...{toPointer:e=>e.length===0?"#":`#/${e.map(h).join("/")}`,pointerPart:h,errorMerge:({keywordLocation:e,instanceLocation:f},i,c)=>({keywordLocation:`${i}${e.slice(1)}`,instanceLocation:`${c}${f.slice(1)}`}),propertyIn:(e,[f,i])=>f.includes(!0)||f.some(c=>c===e)||i.some(c=>new RegExp(c,"u").test(e)),dynamicResolve:(e,f)=>(e.filter(i=>i[f])[0]||{})[f]}},Pt}var Dt,Ir;function Cr(){if(Ir)return Dt;Ir=1;const{format:n,safe:x}=wt(),{scopeMethods:S}=_r(),a=Wt(),y=new Map(Object.entries({null:e=>n("%s === null",e),boolean:e=>n('typeof %s === "boolean"',e),array:e=>n("Array.isArray(%s)",e),object:e=>n('typeof %s === "object" && %s && !Array.isArray(%s)',e,e,e),number:e=>n('typeof %s === "number"',e),integer:e=>n("Number.isInteger(%s)",e),string:e=>n('typeof %s === "string"',e)})),w=({name:e,parent:f,keyval:i,keyname:c})=>{if(e){if(f||i||c)throw new Error("name can be used only stand-alone");return e}if(!f)throw new Error("Can not use property of undefined parent!");const l=w(f);if(i!==void 0){if(c)throw new Error("Can not use key value and name together");if(!["string","number"].includes(typeof i))throw new Error("Invalid property path");return/^[a-z][a-z0-9_]*$/i.test(i)?n("%s.%s",l,x(i)):n("%s[%j]",l,i)}else if(c)return n("%s[%s]",l,c);throw new Error("Unreachable")},h=new Set([].concat(...[Object,Array,String,Number,Boolean].map(e=>Object.getOwnPropertyNames(e.prototype)))),z=(e,f,i,{unmodifiedPrototypes:c,isJSON:l},b)=>{const{gensym:k,genpattern:D,genloop:U}=S(f,i);return{present:j=>{const q=w(j),{parent:A,keyval:T,keyname:X,inKeys:B,checked:te}=j;if(te||B&&l)throw new Error("Unreachable: useless check for undefined");if(B)return n("%s !== undefined",q);if(A&&X){f.hasOwn=a.hasOwn;const re=w(A);return l?n("%s !== undefined && hasOwn(%s, %s)",q,re,X):n("%s in %s && hasOwn(%s, %s)",X,re,re,X)}else if(A&&T!==void 0){if(c&&l&&!h.has(`${T}`))return n("%s !== undefined",q);f.hasOwn=a.hasOwn;const re=w(A);return l?n("%s !== undefined && hasOwn(%s, %j)",q,re,T):n("%j in %s && hasOwn(%s, %j)",T,re,re,T)}throw new Error("Unreachable: present() check without parent")},forObjectKeys:(j,q)=>{const A=k("key");e.block(n("for (const %s of Object.keys(%s))",A,w(j)),()=>{q(i(j,A,!0),A)})},forArray:(j,q,A)=>{const T=U(),X=w(j);e.block(n("for (let %s = %s; %s < %s.length; %s++)",T,q,T,X,T),()=>{A(i(j,T,c,!0),T)})},patternTest:(j,q)=>{const A=j.replace(/[.^$|*+?(){}[\]\\]/gu,"");if(j===`^${A}$`)return n("(%s === %j)",q,j.slice(1,-1));if(b.has(j))return n("true");if([A,`${A}+`,`${A}.*`,`.*${A}.*`].includes(j))return n("%s.includes(%j)",q,A);if([`^${A}`,`^${A}+`,`^${A}.*`].includes(j))return n("%s.startsWith(%j)",q,A);if([`${A}$`,`.*${A}$`].includes(j))return n("%s.endsWith(%j)",q,A);const T=[...A].slice(0,-1).join("");return[`${A}*`,`${A}?`].includes(j)?T.length===0?n("true"):n("%s.includes(%j)",q,T):[`^${A}*`,`^${A}?`].includes(j)?T.length===0?n("true"):n("%s.startsWith(%j)",q,T):n("%s.test(%s)",D(j),q)},compare:(j,q)=>{if(!q||typeof q!="object")return n("%s === %j",j,q);let A;const T=X=>X.length<=3&&X.every(B=>!B||typeof B!="object");if(Array.isArray(q)){if(A=y.get("array")(j),T(q)){let X=n("%s.length === %d",j,q.length);for(let B=0;B<q.length;B++)X=n("%s && %s[%d] === %j",X,j,B,q[B]);return n("%s && %s",A,X)}}else{A=y.get("object")(j);const[X,B]=[Object.keys(q),Object.values(q)];if(T(B)){let te=n("Object.keys(%s).length === %d",j,X.length);X.length>0&&(f.hasOwn=a.hasOwn);for(const re of X)te=n("%s && hasOwn(%s, %j)",te,j,re);for(const re of X)te=n("%s && %s[%j] === %j",te,j,re,q[re]);return n("%s && %s",A,te)}}return f.deepEqual=a.deepEqual,n("%s && deepEqual(%s, %j)",A,j,q)},propvar:i}},Q=/^\([^)]*\) *=>/,ne=/^[^=]*=>/,H=Symbol.for("toJayString");function g(e){if(typeof e=="function"){if(e[H])return e[H];if(Object.getPrototypeOf(e)!==Function.prototype)throw new Error("Can not stringify: a function with unexpected prototype");const f=`${e}`;if(e.prototype){if(!/^function[ (]/.test(f))throw new Error("Unexpected function");return f}if(Q.test(f)||ne.test(f))return f;throw new Error("Can not stringify: only either normal or arrow functions are supported")}else if(typeof e=="object"){const f=Object.getPrototypeOf(e);if(e instanceof RegExp&&f===RegExp.prototype)return n("%r",e);throw new Error("Can not stringify: an object with unexpected prototype")}throw new Error(`Can not stringify: unknown type ${typeof e}`)}return Dt={types:y,buildName:w,jsHelpers:z,jaystring:g},Dt}var _t,Rr;function Fr(){if(Rr)return _t;Rr=1;const{format:n,safe:x,safenot:S}=wt(),{jaystring:a}=Cr(),y=/[{[]/,w=/[}\]]/;return _t=()=>{const h=[];let z=0;const Q=g=>{w.test(g.trim()[0])&&z--,h.push({indent:z,code:g}),y.test(g[g.length-1])&&z++},ne=()=>{if(z!==0)throw new Error("Unexpected indent at build()");const g=h.map(e=>n("%w%s",e.indent*2,e.code)).join(`
`);return/^[a-z][a-z0-9]*$/i.test(g)?`return ${g}`:`return (${g})`},H=g=>{const e=Object.entries(g);for(const[f,i]of e){if(!/^[a-z][a-z0-9]*$/i.test(f))throw new Error("Unexpected scope key!");if(!(typeof i=="function"||i instanceof RegExp))throw new Error("Unexpected scope value!")}return e};return{optimizedOut:!1,size:()=>h.length,write(g,...e){if(typeof g!="string")throw new Error("Format must be a string!");if(g.includes(`
`))throw new Error("Only single lines are supported");return Q(n(g,...e)),!0},block(g,e,f=!1){const i=z;this.write("%s {",g);const c=h.length;if(e(),c===h.length)return h.pop(),z=i,!1;if(c===h.length-1&&!f){const{code:l}=h[h.length-1];if(!/^(if|for) /.test(l))return h.length-=2,z=i,this.write("%s %s",g,l)}return this.write("}")},if(g,e,f){`${g}`=="false"?(f&&f(),e&&(this.optimizedOut=!0)):`${g}`=="true"?(e&&e(),f&&(this.optimizedOut=!0)):e&&this.block(n("if (%s)",g),e,!!f)?f&&this.block(n("else"),f):f&&this.if(S(g),f)},makeModule(g={}){return`(function() {
'use strict'
${H(g).map(([f,i])=>`const ${x(f)} = ${a(i)};`).join(`
`)}
${ne()}})()`},makeFunction(g={}){const e=H(g),f=e.map(c=>c[0]),i=e.map(c=>c[1]);return Function(...f,`'use strict'
${ne()}`)(...i)}}},_t}var Ct,Ar;function Ur(){if(Ar)return Ct;Ar=1;const n=["$schema","$vocabulary","id","$id","$anchor","$ref","definitions","$defs","$recursiveRef","$recursiveAnchor","$dynamicAnchor","$dynamicRef","type","required","default","enum","const","not","allOf","anyOf","oneOf","if","then","else","maximum","minimum","exclusiveMaximum","exclusiveMinimum","multipleOf","divisibleBy","items","maxItems","minItems","additionalItems","prefixItems","contains","minContains","maxContains","uniqueItems","maxLength","minLength","format","pattern","contentEncoding","contentMediaType","contentSchema","properties","maxProperties","minProperties","additionalProperties","patternProperties","propertyNames","dependencies","dependentRequired","dependentSchemas","propertyDependencies","unevaluatedProperties","unevaluatedItems","title","description","deprecated","readOnly","writeOnly","examples","$comment","example","discriminator","removeAdditional"],S=["draft/next","draft/2020-12","draft/2019-09","draft-07","draft-06","draft-04","draft-03"].map(h=>`https://json-schema.org/${h}/schema`),a=["core","applicator","validation","meta-data","format","content"],y=["core","applicator","unevaluated","validation","meta-data","format-annotation","format-assertion","content"],w=[...a.map(h=>`https://json-schema.org/draft/2019-09/vocab/${h}`),...y.map(h=>`https://json-schema.org/draft/2020-12/vocab/${h}`)];return Ct={knownKeywords:n,schemaVersions:S,knownVocabularies:w},Ct}var Ft,zr;function Tr(){if(zr)return Ft;zr=1;const{knownKeywords:n}=Ur();function x(l,b,k,D="keys"){if(!l.has(b))return l.set(b,k);if(l.get(b)!==k)throw new Error(`Conflicting duplicate ${D}: ${b}`)}function S(l){return l.includes("~")?l.replace(/~[01]/g,b=>{switch(b){case"~1":return"/";case"~0":return"~"}throw new Error("Unreachable")}):l}function a(l,b,k){if(typeof l!="object")throw new Error("Invalid input object");if(typeof b!="string")throw new Error("Invalid JSON pointer");const D=b.split("/");if(!["","#"].includes(D.shift()))throw new Error("Invalid JSON pointer");if(D.length===0)return l;let U=l;for(const G of D){if(typeof G!="string")throw new Error("Invalid JSON pointer");k&&k.push(U);const E=S(G);if(typeof U!="object"||!Object.prototype.hasOwnProperty.call(U,E))return;U=U[E]}return U}const y=/^https?:\/\//;function w(l,b){if(typeof l!="string"||typeof b!="string")throw new Error("Unexpected path!");if(b.length===0)return l;const k=l.replace(/#.*/,"");return b.startsWith("#")?`${k}${b}`:!k.includes("/")||y.test(b)?b:y.test(k)?`${new URL(b,k)}`:b.startsWith("/")?b:[...k.split("/").slice(0,-1),b].join("/")}function h(l){return l.map(k=>k&&(k.$id||k.id)||"").filter(k=>k&&typeof k=="string").reduce(w,"")}const z=["properties","patternProperties","$defs","definitions"],Q=["const","enum","examples","example","comment"],ne=Symbol("skip");function H(l,b){const k=(D,U=!1)=>{if(!D||typeof D!="object")return;const G=b(D);if(G!==void 0)return G===ne?void 0:G;for(const E of Object.keys(D)){if(!U&&!Array.isArray(D)&&!n.includes(E)||!U&&Q.includes(E))continue;const ie=k(D[E],!U&&z.includes(E));if(ie!==void 0)return ie}};return k(l)}function g(l,b,k,D=""){const U=w(D,k),G=[],[E,ie=""]=U.split("#"),J=decodeURI(ie),we=(j,q,A=!1,T=!1)=>{if(!j||typeof j!="object")return;const X=j.$id||j.id;let B=q;if(X&&typeof X=="string"){if(B=w(B,X),B===U||B===E&&J==="")G.push([j,l,q]);else if(B===E&&J[0]==="/"){const re=[],ot=a(j,J,re);ot!==void 0&&G.push([ot,l,w(q,h(re))])}}const te=T?j.$dynamicAnchor:j.$anchor;if(te&&typeof te=="string"){if(te.includes("#"))throw new Error("$anchor can't include '#'");if(te.startsWith("/"))throw new Error("$anchor can't start with '/'");B=w(B,`#${te}`),B===U&&G.push([j,l,q])}for(const re of Object.keys(j))!A&&!Array.isArray(j)&&!n.includes(re)||!A&&Q.includes(re)||we(j[re],B,!A&&z.includes(re));!T&&j.$dynamicAnchor&&we(j,q,A,!0)};if(we(l,E),E===D.replace(/#$/,"")&&(J[0]==="/"||J==="")){const j=[],q=a(l,J,j);q!==void 0&&G.push([q,l,h(j)])}if(b.has(E)&&b.get(E)!==l){const j=g(b.get(E),b,`#${ie}`,E);G.push(...j.map(([q,A,T])=>[q,A,w(E,T)]))}return b.has(U)&&G.push([b.get(U),b.get(U),U]),G}function e(l){const b=new Map;return H(l,k=>{if(k!==l&&(k.$id||k.id))return ne;const D=k.$dynamicAnchor;if(D&&typeof D=="string"){if(D.includes("#"))throw new Error("$dynamicAnchor can't include '#'");if(!/^[a-zA-Z0-9_-]+$/.test(D))throw new Error(`Unsupported $dynamicAnchor: ${D}`);x(b,D,k,"$dynamicAnchor")}}),b}const f=(l,b)=>H(l,k=>Object.keys(k).some(D=>b.includes(D))||void 0)||!1,i=(l,b,k=!1)=>{if(!Array.isArray(b))throw new Error("Expected an array of schemas");for(const D of b)H(D,U=>{const G=U.$id||U.id,E=G&&typeof G=="string"?G.replace(/#$/,""):null;if(E&&E.includes("://")&&!E.includes("#"))x(l,E,U,"schema $id in 'schemas'");else if(U===D&&!k)throw new Error("Schema with missing or invalid $id in 'schemas'")});return l},c=(l,b)=>{if(b)return i(c(l),b,!0);if(l)switch(Object.getPrototypeOf(l)){case Object.prototype:return new Map(Object.entries(l));case Map.prototype:return new Map(l);case Array.prototype:return i(new Map,l)}throw new Error("Unexpected value for 'schemas' option")};return Ft={get:a,joinPath:w,resolveReference:g,getDynamicAnchors:e,hasKeywords:f,buildSchemas:c},Ft}var Ut,Mr;function Xn(){if(Mr)return Ut;Mr=1;const n={email:a=>{if(a.length>318)return!1;if(/^[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,20}(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,21}){0,2}@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,60}[a-z0-9])?){0,3}$/i.test(a))return!0;if(!a.includes("@")||/(^\.|^"|\.@|\.\.)/.test(a))return!1;const[w,h,...z]=a.split("@");return!w||!h||z.length!==0||w.length>64||h.length>253||!/^[a-z0-9.-]+$/i.test(h)||!/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(w)?!1:h.split(".").every(Q=>/^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(Q))},hostname:a=>a.length>(a.endsWith(".")?254:253)?!1:/^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*\.?$/i.test(a),date:a=>{if(a.length!==10)return!1;if(a[5]==="0"&&a[6]==="2"){if(/^\d\d\d\d-02-(?:[012][1-8]|[12]0|[01]9)$/.test(a))return!0;const y=a.match(/^(\d\d\d\d)-02-29$/);if(!y)return!1;const w=y[1]|0;return w%16===0||w%4===0&&w%25!==0}return a.endsWith("31")?/^\d\d\d\d-(?:0[13578]|1[02])-31$/.test(a):/^\d\d\d\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)$/.test(a)},time:a=>{if(a.length>27||!/^(?:2[0-3]|[0-1]\d):[0-5]\d:(?:[0-5]\d|60)(?:\.\d+)?(?:z|[+-](?:2[0-3]|[0-1]\d)(?::?[0-5]\d)?)?$/i.test(a))return!1;if(!/:60/.test(a))return!0;const w=a.match(/([0-9.]+|[^0-9.])/g);let h=Number(w[0])*60+Number(w[2]);return w[5]==="+"?h+=1440-Number(w[6]||0)*60-Number(w[8]||0):w[5]==="-"&&(h+=Number(w[6]||0)*60+Number(w[8]||0)),h%1440===1439},"date-time":a=>{if(a.length>38)return!1;const y=/^\d\d\d\d-(?:0[1-9]|1[0-2])-(?:[0-2]\d|3[01])[t\s](?:2[0-3]|[0-1]\d):[0-5]\d:(?:[0-5]\d|60)(?:\.\d+)?(?:z|[+-](?:2[0-3]|[0-1]\d)(?::?[0-5]\d)?)$/i,w=a[5]==="0"&&a[6]==="2";if(w&&a[8]==="3"||!y.test(a))return!1;if(a[17]==="6"){const h=a.slice(11).match(/([0-9.]+|[^0-9.])/g);let z=Number(h[0])*60+Number(h[2]);if(h[5]==="+"?z+=1440-Number(h[6]||0)*60-Number(h[8]||0):h[5]==="-"&&(z+=Number(h[6]||0)*60+Number(h[8]||0)),z%1440!==1439)return!1}if(w){if(/^\d\d\d\d-02-(?:[012][1-8]|[12]0|[01]9)/.test(a))return!0;const h=a.match(/^(\d\d\d\d)-02-29/);if(!h)return!1;const z=h[1]|0;return z%16===0||z%4===0&&z%25!==0}return a[8]==="3"&&a[9]==="1"?/^\d\d\d\d-(?:0[13578]|1[02])-31/.test(a):/^\d\d\d\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)/.test(a)},ipv4:a=>a.length<=15&&/^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)$/.test(a),ipv6:a=>{if(a.length>45||a.length<2)return!1;let y=0,w=0,h=0,z=!1,Q=!1,ne=0,H=!0;for(let e=0;e<a.length;e++){const f=a.charCodeAt(e);if(e===1&&ne===58&&f!==58)return!1;if(f>=48&&f<=57){if(++h>4)return!1}else if(f===46){if(y>6||w>=3||h===0||Q)return!1;w++,h=0}else if(f===58){if(w>0||y>=7)return!1;if(ne===58){if(z)return!1;z=!0}else e===0&&(H=!1);y++,h=0,Q=!1}else if(f>=97&&f<=102||f>=65&&f<=70){if(w>0||++h>4)return!1;Q=!0}else return!1;ne=f}if(y<2||w>0&&(w!==3||h===0))return!1;if(z&&a.length===2)return!0;if(w>0&&!/(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}$/.test(a))return!1;const g=w>0?6:7;return z?(H||h>0)&&y<g:y===g&&H&&h>0},uri:/^[a-z][a-z0-9+\-.]*:(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/?(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,"uri-reference":/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/?(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)?(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,"uri-template":/^(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2}|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,"json-pointer":/^(?:|\/(?:[^~]|~0|~1)*)$/,"relative-json-pointer":/^(?:0|[1-9][0-9]*)(?:|#|\/(?:[^~]|~0|~1)*)$/,uuid:/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,duration:a=>a.length>1&&a.length<80&&(/^P\d+([.,]\d+)?W$/.test(a)||/^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(a)&&/^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(a))},x={alpha:/^[a-zA-Z]+$/,alphanumeric:/^[a-zA-Z0-9]+$/,"hex-digits":/^[0-9a-f]+$/i,"hex-digits-prefixed":/^0x[0-9a-f]+$/i,"hex-bytes":/^([0-9a-f][0-9a-f])+$/i,"hex-bytes-prefixed":/^0x([0-9a-f][0-9a-f])+$/i,base64:a=>a.length%4===0&&/^[a-z0-9+/]*={0,3}$/i.test(a),"json-pointer-uri-fragment":/^#(|\/(\/|[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)$/i,"host-name":n.hostname,"ip-address":n.ipv4,color:/^(#[0-9A-Fa-f]{3,6}|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|rgb\(\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*,\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*,\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*\)|rgb\(\s*(\d?\d%|100%)\s*,\s*(\d?\d%|100%)\s*,\s*(\d?\d%|100%)\s*\))$/};return Ut={core:n,extra:x,weak:{regex:a=>{if(a.length>1e5||/[^\\]\\Z/.test(a))return!1;try{return new RegExp(a,"u"),!0}catch{return!1}}}},Ut}var Tt,qr;function Qn(){if(qr)return Tt;qr=1;const n=(i,c)=>[...new Set([...i,...c])].sort(),x=(i,c)=>i.filter(l=>c.includes(l)),S=i=>(...c)=>i(...c.map(w)),a=i=>(...c)=>w(i(...c.map(w))),y=(i,c)=>i&&!i.includes(c),w=({type:i=null,dyn:c={},...l})=>({type:i&&[...i].sort(),items:y(i,"array")?1/0:l.items||0,properties:y(i,"object")?[!0]:[...l.properties||[]].sort(),patterns:y(i,"object")?[]:[...l.patterns||[]].sort(),required:y(i,"object")?[]:[...l.required||[]].sort(),fullstring:y(i,"string")||l.fullstring||!1,dyn:{item:y(i,"array")?!1:c.item||!1,items:y(i,"array")?0:Math.max(l.items||0,c.items||0),properties:y(i,"object")?[]:n(l.properties||[],c.properties||[]),patterns:y(i,"object")?[]:n(l.patterns||[],c.patterns||[])},unknown:l.unknown&&!(y(i,"object")&&y(i,"array"))||!1}),h=()=>w({}),z=a((i,c)=>({type:i.type&&c.type?x(i.type,c.type):i.type||c.type||null,items:Math.max(i.items,c.items),properties:n(i.properties,c.properties),patterns:n(i.patterns,c.patterns),required:n(i.required,c.required),fullstring:i.fullstring||c.fullstring,dyn:{item:i.dyn.item||c.dyn.item,items:Math.max(i.dyn.items,c.dyn.items),properties:n(i.dyn.properties,c.dyn.properties),patterns:n(i.dyn.patterns,c.dyn.patterns)},unknown:i.unknown||c.unknown})),Q=(i,c)=>c!==!0&&new RegExp(i,"u").test(c),ne=({properties:i,patterns:c},{properties:l,patterns:b})=>{const k=i.filter(E=>l.includes(E)||l.includes(!0)||b.some(ie=>Q(ie,E))),D=l.filter(E=>i.includes(E)||i.includes(!0)||c.some(ie=>Q(ie,E))),U=c.filter(E=>b.includes(E)||l.includes(!0)),G=b.filter(E=>c.includes(E)||i.includes(!0));return{properties:n(k,D),patterns:n(U,G)}},H=({properties:i,patterns:c},{properties:l,patterns:b})=>l.every(k=>i.includes(k)||i.includes(!0)||c.some(D=>Q(D,k)))&&b.every(k=>c.includes(k)||i.includes(!0)),g=a((i,c)=>({type:i.type&&c.type?n(i.type,c.type):null,items:Math.min(i.items,c.items),...ne(i,c),required:y(i.type,"object")&&c.required||y(c.type,"object")&&i.required||x(i.required,c.required),fullstring:i.fullstring&&c.fullstring,dyn:{item:i.dyn.item||c.dyn.item,items:Math.max(i.dyn.items,c.dyn.items),properties:n(i.dyn.properties,c.dyn.properties),patterns:n(i.dyn.patterns,c.dyn.patterns)},unknown:i.unknown||c.unknown})),e=(i,c)=>Object.assign(i,z(i,c)),f=S(({unknown:i,items:c,dyn:l,...b})=>({items:c!==1/0&&(i||l.items>c||l.item),properties:!b.properties.includes(!0)&&(i||!H(b,l))}));return Tt={initTracing:h,andDelta:z,orDelta:g,applyDelta:e,isDynamic:f,inProperties:H},Tt}var Lt,Nr;function Bn(){if(Nr)return Lt;Nr=1;const{format:n,safe:x,safeand:S,safenot:a,safenotor:y}=wt(),w=Fr(),{resolveReference:h,joinPath:z,getDynamicAnchors:Q,hasKeywords:ne}=Tr(),H=Xn(),{toPointer:g,...e}=Wt(),{scopeMethods:f}=_r(),{buildName:i,types:c,jsHelpers:l}=Cr(),{knownKeywords:b,schemaVersions:k,knownVocabularies:D}=Ur(),{initTracing:U,andDelta:G,orDelta:E,applyDelta:ie,isDynamic:J,inProperties:we}=Qn(),j=new Set(["^[\\s\\S]*$","^[\\S\\s]*$","^[^]*$","",".*","^","$"]),q=["null","boolean","number","integer","string"],A=new Map(Object.entries({boolean:$=>typeof $=="boolean",array:$=>Array.isArray($)&&Object.getPrototypeOf($)===Array.prototype,object:$=>$&&Object.getPrototypeOf($)===Object.prototype,finite:$=>Number.isFinite($),natural:$=>Number.isInteger($)&&$>=0,string:$=>typeof $=="string",jsonval:$=>e.deepEqual($,JSON.parse(JSON.stringify($)))})),T=A.get("object"),X=$=>T($)||typeof $=="boolean",B=$=>e.deepEqual($,{type:[]}),te=($,L)=>k.indexOf($)>k.indexOf(`https://json-schema.org/${L}/schema`),re=($,L)=>{const M=`${$}`.replace(/^http:\/\//,"https://").replace(/#$/,"");return k.includes(M)?te(M,L):!0},ot=($,L,M=!1,V=!1)=>Object.freeze({parent:$,keyname:L,inKeys:M,number:V}),Vr=($,L,M=!1)=>Object.freeze({parent:$,keyval:L,checked:M}),bt=Symbol("evaluatedStatic"),Ee=Symbol("optDynamic"),Fe=Symbol("optDynAnchors"),Qe=Symbol("optRecAnchors"),Wr=$=>{if(typeof $=="boolean")return $;if(T($)&&Object.keys($).length===0)return!0},Se=new Set,Be=new Map,Jr=($,L,M,V)=>{if(L){const ae=L.replace(/^http:\/\//,"https://").replace(/#$/,"");M(k.includes(ae),"Unexpected schema version:",ae),Be.set($,{exclusiveRefs:te(ae,"draft/2019-09"),contentValidation:te(ae,"draft/2019-09"),dependentUnsupported:te(ae,"draft/2019-09"),newItemsSyntax:!te(ae,"draft/2020-12"),containsEvaluates:!te(ae,"draft/2020-12"),objectContains:!te(ae,"draft/next"),bookending:te(ae,"draft/next")})}else M(!V,"[requireSchema] $schema is required"),Be.set($,{})},Jt=($,L,M,V,ae="")=>{const{mode:je="default",useDefaults:Kt=!1,removeAdditional:Ue=!1,includeErrors:ye=!1,allErrors:de=!1,contentValidation:Ht,dryRun:ls,lint:et=!1,allowUnusedKeywords:Ne=M.mode==="lax"||M.mode==="spec",allowUnreachable:Kr=M.mode==="lax"||M.mode==="spec",requireSchema:vt=M.mode==="strong",requireValidation:ct=M.mode==="strong",requireStringValidation:ft=M.mode==="strong",forbidNoopValues:Hr=M.mode==="strong",complexityChecks:Zt=M.mode==="strong",unmodifiedPrototypes:Zr=!1,isJSON:Gt=!1,$schemaDefault:Yt=null,formatAssertion:Xt=M.mode!=="spec"||re(L.$schema,"draft/2019-09"),formats:Qt={},weakFormats:Bt=M.mode!=="strong",extraFormats:Gr=!1,schemas:Te,...er}=M,Yr={...H.core,...Bt?H.weak:{},...Gr?H.extra:{},...Qt};if(Object.keys(er).length!==0)throw new Error(`Unknown options: ${Object.keys(er).join(", ")}`);if(!["strong","lax","default","spec"].includes(je))throw new Error(`Invalid mode: ${je}`);if(!ye&&de)throw new Error("allErrors requires includeErrors to be enabled");if(vt&&Yt)throw new Error("requireSchema forbids $schemaDefault");if(je==="strong"){const le={...{requireValidation:ct,requireStringValidation:ft},formatAssertion:Xt,complexityChecks:Zt,requireSchema:vt},I={weakFormats:Bt,allowUnusedKeywords:Ne};for(const[u,oe]of Object.entries(le))if(!oe)throw new Error(`Strong mode demands ${u}`);for(const[u,oe]of Object.entries(I))if(oe)throw new Error(`Strong mode forbids ${u}`)}const{gensym:he,getref:Xr,genref:Qr,genformat:tr}=f(V),Br=fe=>{const le=[];let I=fe;for(;I;)I.name||le.unshift(I),I=I.parent||I.errorParent;if(le.every(ge=>ge.keyval!==void 0))return n("%j",g(le.map(ge=>ge.keyval)));const u=["#"],oe=()=>{const ge=u.map(e.pointerPart).join("/");return u.length=0,ge};let be=null;for(const{keyname:ge,keyval:pt,number:De}of le)if(ge){De||(V.pointerPart=e.pointerPart);const Ve=De?ge:n("pointerPart(%s)",ge),C=`${oe()}/`;be=be?n("%s+%j+%s",be,C,Ve):n("%j+%s",C,Ve)}else pt&&u.push(pt);return u.length>0?n("%s+%j",be,`/${oe()}`):be},Oe=Qr($);let lt=null;const rr=(...fe)=>{const le=lt(...fe);return rr.errors=lt.errors,le};V[Oe]=rr;const en=ne($,["$ref","$recursiveRef","$dynamicRef"]),$t=M[Fe]&&en&&ne($,["$dynamicAnchor"]),tn=()=>M[Fe]?n($t?", dynAnchors = []":", dynAnchors"):n(""),rn=M[Qe]?n(", recursive"):n(""),p=w();p.write("function validate(data%s%s) {",rn,tn()),ye&&p.write("validate.errors = null"),de&&p.write("let errorCount = 0"),M[Ee]&&p.write("validate.evaluatedDynamic = null");let nr=M[Fe]?n(", dynAnchors"):n("");$t&&(p.write("const dynLocal = [{}]"),nr=n(", [...dynAnchors, dynLocal[0] || []]"));const nn=l(p,V,ot,{unmodifiedPrototypes:Zr,isJSON:Gt},j),{present:ke,forObjectKeys:ut,forArray:jt,patternTest:sn,compare:Ot}=nn,Pe=[],ce=()=>Be.get(L),Le=ae?[ae]:[],kt=(fe,le,I,u,oe,be={},{constProp:ge}={})=>{const pt=le.length>0&&le[le.length-1].prop===I,De=()=>le.filter(t=>t.prop===I),Ve=!I.parent||I.checked||I.inKeys&&Gt||De().length>0,C=i(I),_e=(...t)=>Vr(I,...t),Ie=({path:t=[],prop:s=I,source:o,suberr:d})=>{const r=g([...oe,...t]),m=ye?Br(s):null;if(ye===!0&&fe&&o){V.errorMerge=e.errorMerge;const v=[o,r,m];de?(p.write("if (validate.errors === null) validate.errors = []"),p.write("validate.errors.push(...%s.map(e => errorMerge(e, %j, %s)))",...v)):p.write("validate.errors = [errorMerge(%s[0], %j, %s)]",...v)}else if(ye===!0&&fe){const v=n("{ keywordLocation: %j, instanceLocation: %s }",r,m);de?(p.write("if (%s === null) %s = []",fe,fe),p.write("%s.push(%s)",fe,v)):p.write("%s = [%s]",fe,v)}d&&yr(d),de?p.write("errorCount++"):p.write("return false")},pe=(t,s)=>p.if(t,()=>Ie(s));et&&!V.lintErrors&&(V.lintErrors=[]);const xe=(t,s)=>{const o=s!==void 0?` ${JSON.stringify(s)}`:"",d=z(ae,g(oe)),r=`${t}${o} at ${d}`;if(et)return V.lintErrors.push({message:r,keywordLocation:d,schema:$});throw new Error(r)},Et=(t,s)=>{try{return sn(t,s)}catch(o){return xe(o.message),n("false")}},N=(t,...s)=>t||xe(...s),tt=(t,...s)=>N(je==="lax"||je==="spec"||t,...s),Re=(t,s)=>tt(!(u[s]<u[t]),`Invalid ${t} / ${s} combination`),Ae=(t,s="should be specified")=>N(!ct,`[requireValidation] ${t} ${s}`),se=(...t)=>[...oe,...t],We=t=>N(!Ue&&!Kt,`[removeAdditional/useDefaults] uncertain: ${t}`),sr=(t,s)=>N(!Zt,`[complexityChecks] ${t}`,s),ir=t=>Jr(L,t||Yt,N,vt),P=U(),W=t=>ie(P,t);if(typeof u=="boolean")return u===!0?(Ae("schema = true","is not allowed"),{stat:P}):(pe(Ve||I.inKeys?!0:ke(I),{}),W({type:[]}),{stat:P});N(T(u),"Schema is not an object");for(const t of Object.keys(u))N(b.includes(t)||Ne,"Keyword not supported:",t);if(Object.keys(u).length===0)return Ae("empty rules node","is not allowed"),{stat:P};const ze=new Set(Object.keys(u)),or=new Set,Me=(t,...s)=>{N(or.has(t)||ze.has(t),"Unexpected double consumption:",t),N(e.hasOwn(u,t),"Is not an own property:",t),N(s.every(o=>A.has(o)),"Invalid type used in consume"),N(s.some(o=>A.get(o)(u[t])),"Unexpected type for",t),ze.delete(t)},ar=(t,...s)=>(u[t]!==void 0&&Me(t,...s),u[t]),O=(t,s,o,d={})=>{if(u[t]===void 0)return!1;if(Me(t,...s),o!==null)try{const r=o(u[t]);r!==null&&pe(r,{path:[t],...d})}catch(r){if(et&&!r.message.startsWith("[opt] "))xe(r.message);else throw r}return!0};if(u===L?(ir(ar("$schema","string")),O("$vocabulary",["object"],t=>{for(const[s,o]of Object.entries(t))o!==!1&&N(o===!0&&D.includes(s),"Unknown vocabulary:",s);return null})):ce()||ir(L.$schema),ce().objectContains)for(const t of["contains","minContains","maxContains"])or.add(t);O("examples",["array"],null),O("example",["jsonval"],null);for(const t of["title","description","$comment"])O(t,["string"],null);for(const t of["deprecated","readOnly","writeOnly"])O(t,["boolean"],null);O("$defs",["object"],null)||O("definitions",["object"],null);const rt=(t,s,o)=>t===$?x("validate"):Xr(t)||Jt(t,s,M,V,o),qe=()=>Le.length>0?Le[Le.length-1]:"",on=Le.length,cr=t=>(Le.push(z(qe(),t)),null);(!ce().exclusiveRefs||!u.$ref)&&(O("$id",["string"],cr)||O("id",["string"],cr),O("$anchor",["string"],null),O("$dynamicAnchor",["string"],null),(u.$recursiveAnchor||!Hr)&&O("$recursiveAnchor",["boolean"],t=>(t&&Pe.push([u,L,qe()]),null)));const fr=$t&&(u===$||u.id||u.$id);if(fr){const t=Q(u);u!==$&&p.write("dynLocal.unshift({})");for(const[s,o]of t){const d=h(L,Te,`#${s}`,qe()),[r,m,v]=d[0]||[];N(r===o,`Unexpected $dynamicAnchor resolution: ${s}`);const R=rt(r,m,v);p.write("dynLocal[0][%j] = %s",`#${s}`,R)}}const St=t=>M[Ee]&&(u[t]||u[t]===!1||u===$),me=Object.freeze({item:St("unevaluatedItems")?he("evaluatedItem"):null,items:St("unevaluatedItems")?he("evaluatedItems"):null,props:St("unevaluatedProperties")?he("evaluatedProps"):null}),Y=Object.freeze({item:me.item||be.item,items:me.items||be.items,props:me.props||be.props}),lr=()=>(!Y.items||P.items===1/0)&&(!Y.props||P.properties.includes(!0)),ve=t=>{if(Y.item&&t.item&&P.items!==1/0&&p.write("%s.push(%s)",Y.item,t.item),Y.items&&t.items>P.items&&p.write("%s.push(%d)",Y.items,t.items),Y.props&&(t.properties||[]).includes(!0)&&!P.properties.includes(!0))p.write("%s[0].push(true)",Y.props);else if(Y.props){const s=(r,m)=>we(P,{properties:r,patterns:m}),o=(t.properties||[]).filter(r=>!s([r],[])),d=(t.patterns||[]).filter(r=>!s([],[r]));o.length>0&&p.write("%s[0].push(...%j)",Y.props,o),d.length>0&&p.write("%s[1].push(...%j)",Y.props,d);for(const r of t.propertiesVars||[])p.write("%s[0].push(%s)",Y.props,r)}},ur=(t,s,o,d)=>{J(P).items&&t.item&&s&&p.write("%s.push(...%s)",t.item,s),J(P).items&&t.items&&o&&p.write("%s.push(...%s)",t.items,o),J(P).properties&&t.props&&d&&(p.write("%s[0].push(...%s[0])",t.props,d),p.write("%s[1].push(...%s[1])",t.props,d))},an=()=>M[Qe]?Pe.length===0?n(", recursive"):n(", recursive || %s",rt(...Pe[0])):n(""),mt=(t,s)=>{const o=V[t]&&V[t][bt]||{unknown:!0};W(o);const d=n("%s(%s%s%s)",t,C,an(),nr);if(!ye&&lr())return n("!%s",d);const r=he("res"),m=he("err"),v=he("suberr");return ye&&p.write("const %s = validate.errors",m),p.write("const %s = %s",r,d),ye&&p.write("const %s = %s.errors",v,t),ye&&p.write("validate.errors = %s",m),pe(a(r),{...s,source:v}),p.if(r,()=>{const R=J(o).items?n("%s.evaluatedDynamic[0]",t):null,_=J(o).items?n("%s.evaluatedDynamic[1]",t):null,F=J(o).properties?n("%s.evaluatedDynamic[2]",t):null;ur(Y,R,_,F)}),null},dr=(t,s)=>t&&t.every(o=>s.includes(o)),pr=(t,s)=>s.some(o=>t===null||t.includes(o)),mr=(...t)=>De().some(s=>dr(s.stat.type,t)),cn=(...t)=>dr(P.type,t)||mr(...t),Je=(...t)=>pr(P.type,t)&&De().every(s=>pr(s.stat.type,t)),It=(t,s=u)=>{N(typeof t=="string","Invalid pattern:",t),(ct||ft)&&N(/^\^.*\$$/.test(t),"Should start with ^ and end with $:",t),/([{+*].*[{+*]|\)[{+*]|^[^^].*[{+*].)/.test(t)&&s.maxLength===void 0&&sr("maxLength should be specified for pattern:",t)},fn=u.pattern&&!j.has(u.pattern),ln=u.uniqueItems||fn||u.patternProperties||u.format,ht=de&&ln?he("prev"):null,yt=(t,s)=>p.if(t&&ht!==null?n("errorCount === %s",ht):!0,s),hr=()=>[...le,{stat:P,prop:I}],ue=(...t)=>kt(fe,hr(),...t).stat,Ce=(t,...s)=>{if(s[0]===I){const r=Wr(s[1]);if(r===!0)return{sub:n("true"),delta:{}};if(r===!1)return{sub:n("false"),delta:{type:[]}}}const o=he("sub");p.write("const %s = (() => {",o),de&&p.write("let errorCount = 0");const{stat:d}=kt(t,hr(),...s);return de?p.write("return errorCount === 0"):p.write("return true"),p.write("})()"),{sub:o,delta:d}},Rt=()=>{const t=ye&&de?he("suberr"):null;return t&&p.write("let %s = null",t),t},yr=t=>{fe===null||t===null||p.if(t,()=>p.write("%s.push(...%s)",fe,t))},gr=()=>{if(!Ue)return!1;if(Ue===!0)return!0;if(Ue==="keyword")return u.removeAdditional?(Me("removeAdditional","boolean"),!0):!1;throw new Error(`Invalid removeAdditional: ${Ue}`)},gt=(t,s,o)=>{O(t,["object","boolean"],r=>r===!1&&gr()?(p.write("if (%s.length > %s) %s.length = %s",C,s,C,s),null):r===!1&&!o?n("%s.length > %s",C,s):(jt(I,s,(m,v)=>(o&&p.write("if (%s) continue",o(v)),ue(m,r,se(t)))),null))&&W({items:1/0})},At=(t,s)=>{O(t,["object","boolean"],d=>(ut(I,(r,m)=>{p.if(s(m),()=>{d===!1&&gr()?p.write("delete %s[%s]",C,m):ue(r,d,se(t))})}),null))&&W({properties:[!0]})},wr=(t,s,o)=>S(...s.map(d=>n("%s !== %j",t,d)),...o.map(d=>a(Et(d,t)))),br=(t,s)=>{const o=s.map(r=>new RegExp(r,"u")),d=r=>t.includes(r)||o.some(m=>m.test(r));for(const r of P.required)N(d(r),"Unknown required property:",r)},vr=[],un=()=>{const t=(o,d)=>n("!(%d %c %s)",o,d,C);Number.isFinite(u.exclusiveMinimum)?O("exclusiveMinimum",["finite"],o=>t(o,"<")):(O("minimum",["finite"],o=>t(o,u.exclusiveMinimum?"<":"<=")),O("exclusiveMinimum",["boolean"],null)),Number.isFinite(u.exclusiveMaximum)?(O("exclusiveMaximum",["finite"],o=>t(o,">")),Re("minimum","exclusiveMaximum"),Re("exclusiveMinimum","exclusiveMaximum")):u.maximum!==void 0&&(O("maximum",["finite"],o=>t(o,u.exclusiveMaximum?">":">=")),O("exclusiveMaximum",["boolean"],null),Re("minimum","maximum"),Re("exclusiveMinimum","maximum"));const s=u.multipleOf===void 0?"divisibleBy":"multipleOf";O(s,["finite"],o=>{N(o>0,`Invalid ${s}:`,o);const[d,r]=`${o}`.split("e-"),v=`${d}.`.split(".")[1].length+(r?Number(r):0);if(Number.isInteger(o*2**v))return n("%s %% %d !== 0",C,o);V.isMultipleOf=e.isMultipleOf;const R=[C,o,v,Math.round(o*Math.pow(10,v))];return n("!isMultipleOf(%s, %d, 1e%d, %d)",...R)})},dn=()=>{O("maxLength",["natural"],t=>(V.stringLength=e.stringLength,n("%s.length > %d && stringLength(%s) > %d",C,t,C,t))),O("minLength",["natural"],t=>(V.stringLength=e.stringLength,n("%s.length < %d || stringLength(%s) < %d",C,t,C,t))),Re("minLength","maxLength"),yt(!0,()=>{const t=(r,m,v=Yr)=>{const R=typeof r=="string"&&e.hasOwn(v,r);N(R,"Unrecognized format used:",r);const _=v[r],F=_ instanceof RegExp||typeof _=="function";return N(F,"Invalid format used:",r),Xt?_ instanceof RegExp?(e.hasOwn(Qt,r)&&It(_.source),n("!%s.test(%s)",tr(_),m)):n("!%s(%s)",tr(_),m):null};O("format",["string"],r=>(W({fullstring:!0}),t(r,C))),O("pattern",["string"],r=>(It(r),W({fullstring:!0}),j.has(r)?null:a(Et(r,C)))),N(u.contentSchema!==!1,"contentSchema cannot be set to false");const s=Ht===void 0?ce().contentValidation:Ht,o=u.contentEncoding||u.contentMediaType||u.contentSchema;if(N(!o||s||Ne,'"content*" keywords are disabled by default per spec, enable with { contentValidation = true } option (see doc/Options.md for more info)'),o&&s){const r=he("dec");u.contentMediaType&&p.write("let %s = %s",r,C),u.contentEncoding==="base64"?(pe(t("base64",C,H.extra),{path:["contentEncoding"]}),u.contentMediaType&&(V.deBase64=e.deBase64,p.write("try {"),p.write("%s = deBase64(%s)",r,r)),Me("contentEncoding","string")):N(!u.contentEncoding,"Unknown contentEncoding:",u.contentEncoding);let m=!1;if(u.contentMediaType==="application/json"?(p.write("try {"),p.write("%s = JSON.parse(%s)",r,r),m=!0,Me("contentMediaType","string")):N(!u.contentMediaType,"Unknown contentMediaType:",u.contentMediaType),u.contentSchema){N(m,"contentSchema requires contentMediaType application/json");const v=Object.freeze({name:r,errorParent:I});ue(v,u.contentSchema,se("contentSchema")),Me("contentSchema","object","array"),W({fullstring:!0})}u.contentMediaType&&(p.write("} catch (e) {"),Ie({path:["contentMediaType"]}),p.write("}"),u.contentEncoding&&(p.write("} catch (e) {"),Ie({path:["contentEncoding"]}),p.write("}")))}})},pn=()=>{O("maxItems",["natural"],r=>{const m=ce().newItemsSyntax?"prefixItems":"items";return Array.isArray(u[m])&&u[m].length>r&&xe(`Invalid maxItems: ${r} is less than ${m} array length`),n("%s.length > %d",C,r)}),O("minItems",["natural"],r=>n("%s.length < %d",C,r)),Re("minItems","maxItems");const t=r=>{for(let m=0;m<r.length;m++)ue(_e(m),r[m],se(`${m}`));return W({items:r.length}),null};ce().newItemsSyntax?(O("prefixItems",["array"],t),gt("items",n("%d",(u.prefixItems||[]).length))):Array.isArray(u.items)?(O("items",["array"],t),gt("additionalItems",n("%d",u.items.length))):O("items",["object","boolean"],r=>(jt(I,n("0"),m=>ue(m,r,se("items"))),W({items:1/0}),null)),$r(r=>{jt(I,n("0"),(m,v)=>{r(m,()=>{W({dyn:{item:!0}}),ve({item:v})})})});const s=r=>{if(!T(r))return!1;if(r.enum||e.hasOwn(r,"const")||r.type&&(Array.isArray(r.type)?r.type:[r.type]).every(v=>q.includes(v)))return!0;if(r.$ref){const[m]=h(L,Te,r.$ref,qe())[0]||[];if(s(m))return!0}return!1},o=r=>r===!1||s(r),d=()=>!!(u.maxItems!==void 0||o(u.items)||Array.isArray(u.items)&&o(u.additionalItems));yt(!0,()=>{O("uniqueItems",["boolean"],r=>r===!1?null:(d()||sr("maxItems should be specified for non-primitive uniqueItems"),Object.assign(V,{unique:e.unique,deepEqual:e.deepEqual}),n("!unique(%s)",C)))})},Ke=t=>!de&&(P.required.includes(t)||De().some(s=>s.stat.required.includes(t))),mn=()=>{const t=n("Object.keys(%s).length",C);O("maxProperties",["natural"],s=>n("%s > %d",t,s)),O("minProperties",["natural"],s=>n("%s < %d",t,s)),Re("minProperties","maxProperties"),O("propertyNames",["object","boolean"],s=>(ut(I,(o,d)=>{const r=typeof s=="object"&&!s.$ref?{type:"string",...s}:s,m=Object.freeze({name:d,errorParent:o,type:"string"});ue(m,r,se("propertyNames"))}),null)),O("required",["array"],s=>{for(const o of s){if(Ke(o))continue;const d=_e(o);pe(a(ke(d)),{path:["required"],prop:d})}return W({required:s}),null});for(const s of["dependencies","dependentRequired","dependentSchemas"])s!=="dependencies"&&ce().dependentUnsupported||O(s,["object"],o=>{for(const d of Object.keys(o)){const r=typeof o[d]=="string"?[o[d]]:o[d],m=_e(d,Ke(d));if(Array.isArray(r)&&s!=="dependentSchemas"){const v=r.filter(F=>!Ke(F)).map(F=>ke(_e(F))),R=a(S(...v)),_={path:[s,d]};v.length===0||(m.checked?(pe(R,_),W({required:r})):pe(S(ke(m),R),_))}else X(r)&&s!=="dependentRequired"?(We(s),p.if(m.checked?!0:ke(m),()=>{const v=ue(I,r,se(s,d),Y);W(E({},v)),ve(v)})):xe(`Unexpected ${s} entry`)}return null});O("propertyDependencies",["object"],s=>{for(const[o,d]of Object.entries(s)){N(T(d),"propertyDependencies must be an object"),We("propertyDependencies");const r=_e(o,Ke(o));p.if(r.checked?!0:ke(r),()=>{for(const[m,v]of Object.entries(d))N(X(v),"propertyDependencies must contain schemas"),p.if(Ot(i(r),m),()=>{const R=ue(I,v,se("propertyDependencies",o,m),Y);W(E({},R)),ve(R)})})}return null}),O("properties",["object"],s=>{for(const o of Object.keys(s))ge!==o&&ue(_e(o,Ke(o)),s[o],se("properties",o));return W({properties:Object.keys(s)}),null}),yt(u.patternProperties,()=>{if(O("patternProperties",["object"],s=>(ut(I,(o,d)=>{for(const r of Object.keys(s))It(r,u.propertyNames||{}),p.if(Et(r,d),()=>{ue(o,s[r],se("patternProperties",r))})}),W({patterns:Object.keys(s)}),null)),u.additionalProperties||u.additionalProperties===!1){const s=Object.keys(u.properties||{}),o=Object.keys(u.patternProperties||{});u.additionalProperties===!1&&vr.push(()=>br(s,o)),At("additionalProperties",r=>wr(r,s,o))}}),ce().objectContains&&$r(s=>{ut(I,(o,d)=>{s(o,()=>{W({dyn:{properties:[!0]}}),ve({propertiesVars:[d]})})})})},hn=()=>{const t=O("const",["jsonval"],o=>a(Ot(C,o)));if(t&&!Ne)return!0;const s=O("enum",["array"],o=>{const d=o.filter(m=>m&&typeof m=="object"),r=o.filter(m=>!(m&&typeof m=="object"));return y(...[...r,...d].map(m=>Ot(C,m)))});return t||s},$r=t=>{O("contains",["object","boolean"],()=>{We("contains"),ce().objectContains&&Je("array")&&Je("object")&&Ae("possible type confusion in 'contains',","forbid 'object' or 'array'");const s=he("passes");p.write("let %s = 0",s);const o=Rt();return t((d,r)=>{const{sub:m}=Ce(o,d,u.contains,se("contains"));p.if(m,()=>{p.write("%s++",s),ce().containsEvaluates&&(N(!Ue,`Can't use removeAdditional with draft2020+ "contains"`),r())})}),O("minContains",["natural"],d=>n("%s < %d",s,d),{suberr:o})||pe(n("%s < 1",s),{path:["contains"],suberr:o}),O("maxContains",["natural"],d=>n("%s > %d",s,d)),Re("minContains","maxContains"),null})},yn=()=>{O("not",["object","boolean"],r=>Ce(null,I,r,se("not")).sub),u.not&&We("not"),(u.then||u.then===!1||u.else||u.else===!1||Ne)&&O("if",["object","boolean"],r=>{We("if/then/else");const{sub:m,delta:v}=Ce(null,I,r,se("if"),Y);let R,_,F,K;return O("else",["object","boolean"],Z=>(R=()=>{F=ue(I,Z,se("else"),Y),ve(F)},null)),O("then",["object","boolean"],Z=>(_=()=>{K=ue(I,Z,se("then"),Y),ve(G(v,K))},null)),!_&&!B(v)&&(_=()=>ve(v)),p.if(m,_,R),W(E(F||{},G(v,K||{}))),null});const s=(r,m="allOf")=>{N(r.length>0,`${m} cannot be empty`);for(const[v,R]of Object.entries(r))W(ue(I,R,se(m,v),Y));return null};O("allOf",["array"],r=>s(r));let o=null;O("discriminator",["object"],r=>{const m=new Set,v=(ee,Ze,Ge)=>N(ee,`[discriminator]: ${Ze}`,Ge),{propertyName:R,mapping:_,...F}=r,K=_e(R);v(R&&!u.oneOf!=!u.anyOf,"need propertyName, oneOf OR anyOf"),v(Object.keys(F).length===0,'only "propertyName" and "mapping" are supported');const Z=ee=>T(ee)?Object.keys(ee).length:null;return o=(ee,Ze)=>{const Ge=()=>{p.write("switch (%s) {",i(K));let Ye;for(const[bn,Xe]of Object.entries(ee)){const{const:zt,enum:kr,...vn}=(Xe.properties||{})[R]||{};let st=zt!==void 0?[zt]:kr;if(!st&&Xe.$ref){const[$e]=h(L,Te,Xe.$ref,qe())[0]||[];N(T($e),"failed to resolve $ref:",Xe.$ref);const it=($e.properties||{})[R]||{};st=it.const!==void 0?[it.const]:it.enum}const $n=Array.isArray(st)&&st.length>0;v($n,"branches should have unique string const or enum values for [propertyName]");const jn=Object.keys(vn).length===0&&(!zt||!kr);v(jn,"only const OR enum rules are allowed on [propertyName] in branches");for(const $e of st){const it=!_||e.hasOwn(_,$e)&&_[$e]===Xe.$ref;v(it,"mismatching mapping for",$e);const On=typeof $e=="string"&&!m.has($e);v(On,"const/enum values for [propertyName] should be unique strings"),m.add($e),p.write("case %j:",$e)}const Mt=ue(I,Xe,se(Ze,bn),Y,{constProp:R});ve(Mt),Ye=Ye?E(Ye,Mt):Mt,p.write("break")}v(_===void 0||Z(_)===m.size,"mismatching mapping size"),W(Ye),p.write("default:"),Ie({path:[Ze]}),p.write("}")},nt=()=>{if(Ke(R))Ge();else{const Ye=["discriminator","propertyName"];p.if(ke(K),Ge,()=>Ie({path:Ye,prop:K}))}};return de||!e.deepEqual(P.type,["object"])?p.if(c.get("object")(C),nt,()=>Ie({path:["discriminator"]})):nt(),v(e.deepEqual(P.type,["object"]),"has to be checked for type:","object"),v(P.required.includes(R),"propertyName should be placed in required:",R),null},null});const d=(r,m)=>{const v=m.map(F=>F.type||(Array.isArray(F.const)?"array":typeof F.const)),R=v.filter(F=>!q.includes(F)&&F!=="array").length,_=v.filter(F=>!q.includes(F)&&F!=="object").length;(R>1||_>1)&&We(`${r}, use discriminator to make it certain`)};O("anyOf",["array"],r=>{if(N(r.length>0,"anyOf cannot be empty"),r.length===1)return s(r);if(o)return o(r,"anyOf");const m=Rt();if(!lr()){d("anyOf",r);const K=Object.entries(r).map(([Z,ee])=>Ce(m,I,ee,se("anyOf",Z),Y));W(K.map(Z=>Z.delta).reduce((Z,ee)=>E(Z,ee))),pe(y(...K.map(({sub:Z})=>Z)),{path:["anyOf"],suberr:m});for(const{delta:Z,sub:ee}of K)p.if(ee,()=>ve(Z));return null}const v=r.filter(K=>e.hasOwn(K,"const")),R=r.filter(K=>!e.hasOwn(K,"const"));d("anyOf",R);const _=[...v,...R];let F;if(ce().exclusiveRefs){let K=()=>Ie({path:["anyOf"],suberr:m});for(const[Z,ee]of Object.entries(_).reverse()){const Ze=K;K=()=>{const{sub:Ge,delta:nt}=Ce(m,I,ee,se("anyOf",Z));p.if(a(Ge),Ze),F=F?E(F,nt):nt}}K()}else{const K=Object.entries(r).map(([Z,ee])=>Ce(m,I,ee,se("anyOf",Z),Y));F=K.map(Z=>Z.delta).reduce((Z,ee)=>E(Z,ee)),pe(y(...K.map(({sub:Z})=>Z)),{path:["anyOf"],suberr:m})}return W(F),null}),O("oneOf",["array"],r=>{if(N(r.length>0,"oneOf cannot be empty"),r.length===1)return s(r);if(o)return o(r,"oneOf");d("oneOf",r);const m=he("passes");p.write("let %s = 0",m);const v=Rt();let R,_=0;const F=Object.entries(r).map(([K,Z])=>{!ye&&_++>1&&pe(n("%s > 1",m),{path:["oneOf"]});const ee=Ce(v,I,Z,se("oneOf",K),Y);return p.if(ee.sub,()=>p.write("%s++",m)),R=R?E(R,ee.delta):ee.delta,ee});W(R),pe(n("%s !== 1",m),{path:["oneOf"]}),p.if(n("%s === 0",m),()=>yr(v));for(const K of F)p.if(K.sub,()=>ve(K.delta));return null})},He=(t,s,o)=>{const[d,r]=[p.size(),ze.size];p.if(cn(...s)?!0:o,t),(d!==p.size()||r!==ze.size)&&N(Je(...s),"Unexpected rules in type",u.type)},gn=()=>{if(P.items===1/0)u.unevaluatedItems===!1&&Me("unevaluatedItems","boolean");else if(u.unevaluatedItems||u.unevaluatedItems===!1)if(J(P).items){if(!M[Ee])throw new Error("[opt] Dynamic unevaluated tracing not enabled");const t=n("Math.max(%d, ...%s)",P.items,Y.items),s=o=>n("%s.includes(%s)",Y.item,o);gt("unevaluatedItems",t,ce().containsEvaluates?s:null)}else gt("unevaluatedItems",n("%d",P.items))},wn=()=>{yt(P.patterns.length>0||P.dyn.patterns.length>0||P.unknown,()=>{if(P.properties.includes(!0))u.unevaluatedProperties===!1&&Me("unevaluatedProperties","boolean");else if(u.unevaluatedProperties||u.unevaluatedProperties===!1){const t=s=>wr(s,P.properties,P.patterns);if(J(P).properties){if(!M[Ee])throw new Error("[opt] Dynamic unevaluated tracing not enabled");V.propertyIn=e.propertyIn;const s=d=>n("!propertyIn(%s, %s)",d,Y.props);At("unevaluatedProperties",d=>S(t(d),s(d)))}else u.unevaluatedProperties===!1&&br(P.properties,P.patterns),At("unevaluatedProperties",t)}})},jr=()=>{if(ht!==null&&p.write("const %s = errorCount",ht),hn()){const t=[...c.keys()];if(W({properties:[!0],items:1/0,type:t,fullstring:!0}),!Ne){N(ze.size===0,"Unexpected keywords mixed with const or enum:",[...ze]);return}}He(un,["number","integer"],c.get("number")(C)),He(dn,["string"],c.get("string")(C)),He(pn,["array"],c.get("array")(C)),He(mn,["object"],c.get("object")(C)),yn(),He(gn,["array"],c.get("array")(C)),He(wn,["object"],c.get("object")(C));for(const t of vr)t();ur(be,me.item,me.items,me.props)},Or=()=>{if(me.item&&p.write("const %s = []",me.item),me.items&&p.write("const %s = [0]",me.items),me.props&&p.write("const %s = [[], []]",me.props),O("$ref",["string"],s=>{const o=h(L,Te,s,qe()),[d,r,m]=o[0]||[];if(!d&&d!==!1&&(xe("failed to resolve $ref:",s),et))return null;const v=rt(d,r,m),R=d===$?Oe:v;if(!V[R])throw new Error("Unexpected: coherence check failed");if(!V[R][bt]&&d.type){const _=Array.isArray(d.type)?d.type:[d.type];W({type:_}),ct&&(Se.add(R),_.includes("array")&&W({items:1/0}),_.includes("object")&&W({properties:[!0]})),ft&&_.includes("string")&&(Se.add(R),W({fullstring:!0}))}return mt(v,{path:["$ref"]})}),ce().exclusiveRefs&&(N(!M[Ee],"unevaluated* is supported only on draft2019-09 and above"),u.$ref))return;O("$recursiveRef",["string"],s=>{if(!M[Qe])throw new Error("[opt] Recursive anchors are not enabled");N(s==="#",'Behavior of $recursiveRef is defined only for "#"');const o=h(L,Te,"#",qe()),[d,r,m]=o[0];tt(d.$recursiveAnchor,"$recursiveRef without $recursiveAnchor");const v=rt(d,r,m),R=d.$recursiveAnchor?n("(recursive || %s)",v):v;return mt(R,{path:["$recursiveRef"]})}),O("$dynamicRef",["string"],s=>{if(!M[Fe])throw new Error("[opt] Dynamic anchors are not enabled");tt(/^[^#]*#[a-zA-Z0-9_-]+$/.test(s),"Unsupported $dynamicRef format");const o=s.replace(/^[^#]+/,""),d=h(L,Te,s,qe());if(!d[0]&&!ce().bookending){tt(!1,"$dynamicRef bookending resolution failed (even though not required)"),V.dynamicResolve=e.dynamicResolve;const K=n("dynamicResolve(dynAnchors || [], %j)",o);return mt(K,{path:["$dynamicRef"]})}N(d[0],"$dynamicRef bookending resolution failed",s);const[r,m,v]=d[0],R=r.$dynamicAnchor&&`#${r.$dynamicAnchor}`===o;tt(R,"$dynamicRef without $dynamicAnchor in the same scope");const _=rt(r,m,v);V.dynamicResolve=e.dynamicResolve;const F=R?n("(dynamicResolve(dynAnchors || [], %j) || %s)",o,_):_;return mt(F,{path:["$dynamicRef"]})});let t=null;O("type",["string","array"],s=>{const o=Array.isArray(s)?s:[s];for(const r of o)N(typeof r=="string"&&c.has(r),"Unknown type:",r);if(I.type)return N(e.deepEqual(o,[I.type]),"One type allowed:",I.type),W({type:[I.type]}),null;if(mr(...o))return null;const d=o.filter(r=>Je(r));return d.length===0&&xe("No valid types possible"),W({type:o}),t=y(...d.map(r=>c.get(r)(C))),null}),t&&de?p.if(t,()=>Ie({path:["type"]}),jr):(t&&pe(t,{path:["type"]}),jr()),P.items<1/0&&u.maxItems<=P.items&&W({items:1/0})};if(u.default!==void 0&&Kt){Ve&&xe("Can not apply default value here (e.g. at root)");const t=ar("default","jsonval");p.if(ke(I),Or,()=>p.write("%s = %j",C,t))}else O("default",["jsonval"],null),p.if(Ve?!0:ke(I),Or);if(Le.length=on,Pe[0]&&Pe[Pe.length-1][0]===u&&Pe.pop(),fr&&u!==$&&p.write("dynLocal.shift()"),Kr||N(!p.optimizedOut,"some checks are never reachable"),pt){const t=["not","if","then","else"].includes(oe[oe.length-1]),s=["oneOf","anyOf","allOf"].includes(oe[oe.length-2]),o=["dependencies","dependentSchemas"].includes(oe[oe.length-2]),d=["propertyDependencies"].includes(oe[oe.length-3]);N(t||s||o||d,"Unexpected logical path")}else if(!oe.includes("not")&&((!($!==L&&u===$)||Se.has(Oe))&&(Se.delete(Oe),P.type||Ae("type"),Je("array")&&P.items!==1/0&&Ae(u.items?"additionalItems or unevaluatedItems":"items rule"),Je("object")&&!P.properties.includes(!0)&&Ae("additionalProperties or unevaluatedProperties"),!P.fullstring&&ft&&xe("[requireStringValidation] pattern, format or contentSchema should be specified for strings, use pattern: ^[\\s\\S]*$ to opt-out")),typeof u.propertyNames!="object"))for(const s of["additionalProperties","unevaluatedProperties"])u[s]&&Ae(`wild-card ${s}`,"requires propertyNames");return u.properties&&!u.required&&Ae("if properties is used, required"),N(ze.size===0||Ne,"Unprocessed keywords:",[...ze]),{stat:P,local:me}},{stat:xt,local:dt}=kt(n("validate.errors"),[],{name:x("data")},$,[]);if(Se.has(Oe))throw new Error("Unexpected: unvalidated cyclic ref");if(M[Ee]&&(J(xt).items||J(xt).properties)){if(!dt)throw new Error("Failed to trace dynamic properties");p.write("validate.evaluatedDynamic = [%s, %s, %s]",dt.item,dt.items,dt.props)}return de?p.write("return errorCount === 0"):p.write("return true"),p.write("}"),et||(lt=p.makeFunction(V),delete V[Oe],V[Oe]=lt),V[Oe][bt]=xt,Oe},at=($,L)=>{if(!Array.isArray($))throw new Error("Expected an array of schemas");try{const M=Object.create(null),{getref:V}=f(M);Se.clear(),Be.clear();const ae=$.map(je=>V(je)||Jt(je,je,L,M));if(Se.size!==0)throw new Error("Unexpected: not all refs are validated");return{scope:M,refs:ae}}catch(M){if(!L[Ee]&&M.message==="[opt] Dynamic unevaluated tracing not enabled")return at($,{...L,[Ee]:!0});if(!L[Fe]&&M.message==="[opt] Dynamic anchors are not enabled")return at($,{...L,[Fe]:!0});if(!L[Qe]&&M.message==="[opt] Recursive anchors are not enabled")return at($,{...L,[Qe]:!0});throw M}finally{Se.clear(),Be.clear()}};return Lt={compile:at},Lt}var Vt,Pr;function es(){if(Pr)return Vt;Pr=1;const n=Fr(),{buildSchemas:x}=Tr(),{compile:S}=Bn(),{deepEqual:a}=Wt(),y=g=>function e(f){if(!a(f,JSON.parse(JSON.stringify(f))))return e.errors=[{instanceLocation:"#",error:"not JSON compatible"}],!1;const i=g(f);return e.errors=g.errors,i},w=g=>e=>a(e,JSON.parse(JSON.stringify(e)))&&g(e),h=(g,{parse:e=!1,multi:f=!1,jsonCheck:i=!1,isJSON:c=!1,schemas:l=[],...b}={})=>{if(i&&c)throw new Error("Can not specify both isJSON and jsonCheck options");if(e&&(i||c))throw new Error("jsonCheck and isJSON options are not applicable in parser mode");const k=e?"strong":"default",D=c||i||e,U=f?g:[g],G={mode:k,...b,schemas:x(l,U),isJSON:D},{scope:E,refs:ie}=S(U,G);if(b.dryRun)return;if(b.lint)return E.lintErrors;const J=n();if(e?E.parseWrap=b.includeErrors?z:Q:i&&(E.deepEqual=a,E.jsonCheckWrap=b.includeErrors?y:w),f){J.write("[");for(const j of ie.slice(0,-1))J.write("%s,",j);ie.length>0&&J.write("%s",ie[ie.length-1]),J.write("]"),e?J.write(".map(parseWrap)"):i&&J.write(".map(jsonCheckWrap)")}else e?J.write("parseWrap(%s)",ie[0]):i?J.write("jsonCheckWrap(%s)",ie[0]):J.write("%s",ie[0]);const we=J.makeFunction(E);return we.toModule=({semi:j=!0}={})=>J.makeModule(E)+(j?";":""),we.toJSON=()=>g,we},z=g=>e=>{if(typeof e!="string")return{valid:!1,error:"Input is not a string"};try{const f=JSON.parse(e);if(!g(f)){const{keywordLocation:i,instanceLocation:c}=g.errors[0];return{valid:!1,error:`JSON validation failed for ${i.slice(i.lastIndexOf("/")+1)} at ${c}`,errors:g.errors}}return{valid:!0,value:f}}catch({message:f}){return{valid:!1,error:f}}},Q=g=>e=>{if(typeof e!="string")return{valid:!1};try{const f=JSON.parse(e);return g(f)?{valid:!0,value:f}:{valid:!1}}catch{return{valid:!1}}};return Vt={validator:h,parser:function(g,{parse:e=!0,...f}={}){if(!e)throw new Error("can not disable parse in parser");return h(g,{parse:e,...f})},lint:function(g,{lint:e=!0,...f}={}){if(!e)throw new Error("can not disable lint option in lint()");return h(g,{lint:e,...f})}},Vt}var ts=es();const rs=(n,x)=>ts.validator(n,{...Yn,schemas:{[Dr]:x}});class ns{map=new WeakMap;has(x){return this.map.has(x)}get(x){return this.map.get(x)}set(x,S){this.map.set(x,S)}clear(){this.map=new WeakMap}}function ss(n,x=new ns){let S=!1,a=new WeakRef({}),w=Nn(x,h=>n(S?Ln(h,Dr):h,a.deref()));return(h,z)=>(S=h!==z,a.deref()!==z&&(a=new WeakRef(z),x.clear()),w(h))}function is(n){const x=new WeakMap,S={},a=Pn(x,y=>n(y,S));return y=>a(y.schema)}function Lr({createSchemaValidator:n,valueToJSON:x}){return{isValid(S,a,y){return typeof S=="boolean"?S:n(S,a)(x(y))}}}function os(n){return{validateFormValue(x,S){const a=n.createSchemaValidator(x,x);return a(n.valueToJSON(S)),Vn(Lr(n),n.merger(),x,a.errors,S)}}}function as({createFieldSchemaValidator:n,valueToJSON:x}){return{validateFieldValue(S,a){const y=n(S);return y(x(a)),Wn(S,y.errors,a)}}}function cs({factory:n=rs,validatorsCache:x,createSchemaValidator:S=ss(n,x),createFieldSchemaValidator:a=is(n),valueToJSON:y=h=>h,...w}){const h={...w,valueToJSON:y,createSchemaValidator:S,createFieldSchemaValidator:a};return Object.assign(Lr(h),os(h),as(h))}var fs=zn("<!> <pre> </pre>",1);function Is(n,x){kn(x,!0);const S=Un({...Jn,schema:Zn,uiSchema:Hn,validator:cs,fieldsValidationMode:_n|Cn|Fn,initialValue:Kn});var a=fs(),y=xn(a);Tn(y,{get form(){return S},novalidate:!0});var w=Rn(y,2),h=Mn(w,!0);qn(w),En(z=>An(h,z),[()=>JSON.stringify(Dn(S),null,2)]),Sn(n,a),In()}export{Is as default};
