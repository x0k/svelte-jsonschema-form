---
title: Form actions
type: package
package: "@sjsf/sveltekit"
sidebar:
  order: 0
---

import { Code, Tabs, TabItem } from "@astrojs/starlight/components";
import { DEFAULT_ID_SEPARATOR, DEFAULT_ID_PSEUDO_SEPARATOR } from '@sjsf/form/id-builders/legacy';

import Npm from '@/components/npm.astro';

import modelCode from '%/sveltekit-starter/src/lib/post.ts?raw'
import clientCode from '%/sveltekit-starter/src/routes/form-actions/+page.svelte?raw';
import serverCode from '%/sveltekit-starter/src/routes/form-actions/+page.server?raw'
import clientFlexCode from '%/sveltekit-starter/src/routes/form-actions-flex/+page.svelte?raw';
import serverFlexCode from '%/sveltekit-starter/src/routes/form-actions-flex/+page.server?raw';

Since this is a `Svelte` library, you may want to use it with the `SvelteKit`.

With this package you will be able to perform server-side validation of the form data
even if the user has `JavaScript` disabled.

## Installation

<Npm pkg="@sjsf/sveltekit" />

## Example

See details in the sections below

<Tabs>
  <TabItem label='+page.svelte' >
    <Code code={clientCode} lang='svelte' />
  </TabItem>
  <TabItem label='+page.server.ts'>
    <Code code={serverCode} lang='typescript' />
  </TabItem>
  <TabItem label='lib/post.ts'>
    <Code code={modelCode} lang='typescript' />
  </TabItem>
</Tabs>

## Server

If you want to populate the form from the database,
you can return `InitialFormData` object inside the `load` function.

```typescript
import type { InitialFormData } from "@sjsf/sveltekit";

export const load = async () => {
  return {
    // Should match action name
    form: {
      schema,
      initialValue: { title: "New post", content: "" },
    } satisfies InitialFormData<CreatePost>,
  };
};
```

You can define an [action](https://svelte.dev/docs/kit/form-actions)
using the `createAction` function.
In this case, the callback provided as the second argument
will only be called if the form data passes validation successfully.

```ts
export const actions = {
  default: createAction(
    {
      /* options */
    },
    (data, event, meta) => {
      /* logic */
    }
  ),
} satisfies Actions;
```

If any errors occur during processing,
you can return an array of `ValidationError` objects.

```ts
if (title.length > 100) {
  return [{ path: ["title"], message: "Title is too long" }];
}
```

### Advanced API

If you need more control over the action handler - for example,
to perform checks before processing form data -
you can use the `createFormHandler` API:

:::note

You must return the `form` (the key corresponding to the form name)
in every branch of the handler's code.
`redirect` and `error` helpers are also allowed.

:::

<Tabs>
  <TabItem label='+page.server.ts'>
    <Code code={serverFlexCode} lang='typescript' />
  </TabItem>
  <TabItem label='lib/post.ts'>
    <Code code={modelCode} lang='typescript' />
  </TabItem>
</Tabs>

## Client

On the client side you can use `SvelteKitForm` component ([see example](#example)).
Or use more flexible solution:

:::note

For correct operation, you must use ID Builder from the `@sjsf/sveltekit` module.

:::

<Code code={clientFlexCode} lang='svelte' />

The form data type will be inferred from the `ActionData` and `PageData` type.

If the value of the form cannot be inferred from `action` and
you did not use `load` function, then the third generic parameter of
the `createMeta` function will be used as the form data type
(default type is `SchemaValue`).


According to Svelte documentation your form should always use `POST` requests.

### Progressive enhancement

By default, the form will work even with JavaScript disabled, but you should consider the following limitations of this mode of operation:

- `action` should be created with `sendData: true` to persist form data between page updates
- Form fields for `oneOf`, `anyOf`, `dependencies`, `additionalProperties` and `additionalItems`
will not expand/switch their state.
- Some widgets (like multiselect, depends on the theme) may will not work, because they require `JavaScript`.

## Comparison with Superforms

Unlike [Superforms](https://github.com/ciscoheat/sveltekit-superforms),
SJSF focuses on generating forms from JSON Schemas and managing their state,
while the SvelteKit integration is just an additional layer.
However, feel free to [open feature requests](https://github.com/x0k/svelte-jsonschema-form/issues/new/choose)
if something important is still missing.

### Missing features

- [Status messages](https://superforms.rocks/concepts/messages)
- [Snapshots](https://superforms.rocks/concepts/snapshots)

### Tainted fields

SJSF does not track the difference between the current and initial form state.
The `form.isChanged` property becomes `true` after any interaction with a form field
until the form is either successfully submitted or reset.

You can use the following code to check whether any changes have been made.

```ts
import { isSchemaValueDeepEqual } from '@sjsf/form/core';
import { getValueSnapshot } from '@sjsf/form';
import { preventPageReload } from '@sjsf/form/prevent-page-reload.svelte';

preventPageReload({
  get isChanged() {
    return form.isChanged && !isSchemaValueDeepEqual(initialValue, getValueSnapshot(form))
  }
})
```

### Available events

- `onSuccess` — triggered when a request completes successfully,
receiving an `ActionResult<NonNullable<ActionData>>` as the result
- `onFailure` — triggered when a request fails,
receiving a `FailedTask<unknown>` as the argument
- `onSubmitError` — triggered when client-side validation errors are present
- `onSubmissionFailure` — triggered when an error occurs during validation

### Loading timers

Use `request.isProcessed` and `request.isDelayed` to access loading timers.

```ts
const { form, request } = setupSvelteKitForm(meta, {
  delayedMs: 500,
  timeoutMs: 8000,
  ...,
})
```

### Multiple forms

Use `idPrefix` to create multiple forms.

**Client**

```ts
const { form, request } = setupSvelteKitForm(meta, {
  idPrefix: "foo",
  ...,
})
```

**Server**

```ts
export const actions = {
  default: createAction(
    {
      /* options */
    },
    (data: Model, _event, { idPrefix }) => {
      console.log(idPrefix, data);
    }
  )
} satisfies Actions
```

### Submit behavior

Use the `combinator` option to control the behavior of multiple form submissions.

- `forgetPrevious`
- `abortPrevious`
- `waitPrevious`
- `throttle`

```ts
import { waitPrevious } from '@sjsf/form/lib/task.svelte'

const { form, request } = setupSvelteKitForm(meta, {
  combinator: waitPrevious
  ...,
})
```
